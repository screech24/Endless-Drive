<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Endless Drive - 3D Driving Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            background-color: #000033; /* Match the cyberpunk theme skyColor */
            color: white;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        #score {
            font-size: 24px;
            margin-bottom: 10px;
        }
        #speed {
            font-size: 18px;
        }
        #powerup {
            font-size: 18px;
            color: #ffcc00;
        }
        #version {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        #menu h2 {
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
            font-size: 32px;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }
        button {
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff00ff;
            color: #00ffff;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px 5px;
            cursor: pointer;
            border-radius: 5px;
            font-family: 'Orbitron', 'Rajdhani', sans-serif;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }
        button:hover {
            background-color: rgba(255, 0, 255, 0.2);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
        }
        .car-select {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
        }
        .theme-select {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            width: 300px;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        /* Tutorial, Credits, and Leaderboard pages */
        #tutorialPage, #creditsPage, #leaderboardPage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: left;
            display: none;
            width: 300px;
            max-height: 80vh;
            overflow-y: auto;
            border: 2px solid #ff00ff;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
        }
        
        #gameOver h2, #tutorialPage h2, #creditsPage h2, #leaderboardPage h2 {
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
            letter-spacing: 2px;
        }
        
        /* Tutorial page specific layout */
        #tutorialContent {
            display: flex;
            flex-direction: column;
        }
        
        /* Media query for landscape mode tutorial layout */
        @media (min-width: 768px) and (orientation: landscape) {
            #tutorialPage {
                width: 600px;
            }
            
            #tutorialContent {
                flex-direction: row;
                justify-content: space-between;
            }
            
            #controlInstructions, #powerupInfo {
                width: 48%;
            }
            
            #controlInstructions {
                margin-right: 10px;
            }
        }
        
        /* Portrait mode message */
        #portraitMessage {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 1000;
            padding: 20px;
        }
        
        #portraitMessage img {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
        }
        
        /* Power-up info styles */
        #powerupInfo {
            margin-top: 20px;
            text-align: left;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding-top: 15px;
        }
        
        .powerup-item {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .powerup-icon {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        
        .speed-icon {
            background-color: rgba(0, 255, 0, 0.3);
            border: 2px solid #00ff00;
        }
        
        .shield-icon {
            background-color: rgba(0, 136, 255, 0.3);
            border: 2px solid #0088ff;
        }
        
        .nitro-icon {
            background-color: rgba(255, 204, 0, 0.3);
            border: 2px solid #ffcc00;
        }
        
        .powerup-desc {
            font-size: 14px;
        }
        
        /* Mobile Controls Styles */
        #mobileControls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default, shown via JS for touch devices */
            pointer-events: none;
            z-index: 100;
        }
        
        .control-container {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        
        #joystickZone {
            width: 120px;
            height: 120px;
            position: relative;
            margin-left: 20px;
            pointer-events: auto;
        }
        
        .pedal-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-right: 20px;
            pointer-events: auto;
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 0, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
        }
        
        .accelerate-btn {
            background-color: rgba(0, 255, 100, 0.6);
        }
        
        .brake-btn {
            background-color: rgba(255, 50, 50, 0.6);
        }
        
        /* Media query for mobile devices */
        @media (max-width: 768px) {
            #menu, #gameOver, #tutorialPage, #creditsPage, #leaderboardPage {
                width: 90%;
                max-width: 300px;
            }
            
            button {
                padding: 12px 20px;
                margin: 8px 4px;
            }
        }
        
        /* Landscape orientation specific styles */
        @media (orientation: landscape) {
            .control-container {
                bottom: 20px;
            }
            
            #joystickZone {
                width: 150px;
                height: 150px;
                position: absolute;
                bottom: 10px;
                left: 20px;
                margin-left: 0;
            }
            
            .pedal-controls {
                margin-right: 30px;
                position: absolute;
                right: 20px;
                bottom: 10px;
            }
            
            #menu, #gameOver, #tutorialPage, #creditsPage, #leaderboardPage {
                max-width: 400px;
                max-height: 80vh;
            }
            
            /* Landscape tutorial layout */
            #tutorialContent {
                flex-direction: row;
                justify-content: space-between;
                gap: 20px;
            }
            
            #controlInstructions, #powerupInfo {
                width: 48%;
                margin-top: 0;
                border-top: none;
                padding-top: 0;
            }
            
            #powerupInfo {
                border-left: 1px solid rgba(255, 255, 255, 0.3);
                padding-left: 15px;
            }
        }
        
        /* Portrait orientation specific styles */
        @media (orientation: portrait) and (max-width: 768px) {
            #portraitMessage {
                display: flex;
                flex-direction: column;
            }
        }
        
        /* Preloader styles */
        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000033; /* Match the cyberpunk theme skyColor */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        
        .loader {
            width: 80px;
            height: 80px;
            border: 5px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 5px solid #ff00ff;
            border-right: 5px solid #00ffff;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <!-- Add Google Fonts for cyberpunk style -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Preloader -->
    <div id="preloader">
        <div class="loader"></div>
    </div>

    <div id="ui">
        <div id="score">Distance: 0m</div>
        <div id="speed">Speed: 0 km/h</div>
        <div id="powerup"></div>
    </div>
    <div id="version">v1.5.8</div>

    <div id="menu">
        <h2>Endless Drive</h2>
        <button id="startGame">Start Game</button>
        <button id="tutorialBtn">How to Play</button>
        <button id="leaderboardBtn">Leaderboard</button>
        <button id="creditsBtn">Credits</button>
    </div>

    <div id="tutorialPage">
        <h2>How to Play</h2>
        <div id="tutorialContent">
            <div id="controlInstructions">
                <h3>Controls</h3>
                <p><strong>Desktop Controls:</strong><br>Arrow keys or WASD to drive<br>Space for nitro (when collected)</p>
                <p><strong>Mobile Controls:</strong><br>Left joystick to steer<br>Right buttons to accelerate/brake<br>Nitro activates automatically when collected</p>
            </div>
            
            <!-- Power-up information section -->
            <div id="powerupInfo">
                <h3>Power-Ups</h3>
                <div class="powerup-item">
                    <div class="powerup-icon speed-icon">▲</div>
                    <div class="powerup-desc">Speed Boost: Gradually increases your top speed by 20% for 5 seconds, allowing you to maintain higher speeds</div>
                </div>
                <div class="powerup-item">
                    <div class="powerup-icon shield-icon">◯</div>
                    <div class="powerup-desc">Shield: Protects from obstacles and track edges for 10 seconds</div>
                </div>
                <div class="powerup-item">
                    <div class="powerup-icon nitro-icon">◆</div>
                    <div class="powerup-desc">Nitro: Provides an immediate powerful acceleration burst for 2 seconds, perfect for quick overtaking</div>
                </div>
            </div>
        </div>
        <button id="tutorialBackBtn">Back to Menu</button>
    </div>

    <div id="creditsPage">
        <h2>Credits</h2>
        <div>
            <p><strong>Game Development:</strong><br>Endless Drive Team</p>
            <p><strong>Libraries Used:</strong><br>Three.js - 3D Graphics<br>NippleJS - Mobile Controls</p>
            <p><strong>Special Thanks:</strong><br>To all the players who enjoy this game!</p>
        </div>
        <button id="creditsBackBtn">Back to Menu</button>
    </div>

    <div id="leaderboardPage">
        <h2>Leaderboard</h2>
        <div id="highScoreDisplay">
            <h3>Your High Score</h3>
            <p id="personalHighScore">0m</p>
        </div>
        <button id="leaderboardBackBtn">Back to Menu</button>
    </div>

    <div id="gameOver">
        <h2>Game Over</h2>
        <div id="finalScore">Distance: 0m</div>
        <div id="highScore">High Score: 0m</div>
        <button id="shareScore">Share Score</button>
        <button id="playAgain">Play Again</button>
        <button id="mainMenu">Main Menu</button>
    </div>
    
    <!-- Portrait mode message -->
    <div id="portraitMessage">
        <div>
            <svg width="80" height="80" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M4 20H20C21.1 20 22 19.1 22 18V6C22 4.9 21.1 4 20 4H4C2.9 4 2 4.9 2 6V18C2 19.1 2.9 20 4 20Z" stroke="white" stroke-width="2"/>
                <path d="M12 17V7M8 13L12 17L16 13" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <h3>Please rotate your device</h3>
        <p>Endless Drive works best in landscape mode</p>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div class="control-container">
            <div id="joystickZone"></div>
            <div class="pedal-controls">
                <button class="control-btn accelerate-btn" id="accelerateBtn">↑</button>
                <button class="control-btn brake-btn" id="brakeBtn">↓</button>
            </div>
        </div>
    </div>

    <!-- Add nipplejs library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, car;
        let track = [];
        let obstacles = [];
        let powerUps = [];
        let groundTiles = []; // Add array to track ground tiles
        let score = 0;
        let speed = 0;
        let maxSpeed = 0;
        let acceleration = 0;
        let steering = 0;
        let activePowerUp = null;
        let powerUpTimer = 0;
        let gameActive = false;
        let cameraOffset = new THREE.Vector3(0, 5, -10);
        let clock = new THREE.Clock();
        let highScore = localStorage.getItem('highScore') || 0;
        let carType = 'sportsCar';
        let theme = 'cyberpunk';
        let currentSegment = 0;
        let segmentLength = 50;
        let trackWidth = 10;
        let groundTileSize = 100; // Size of each ground tile
        
        // Add orbit camera variables
        let orbitCamera, orbitControls;
        let isOrbitCameraActive = false;
        
        let carSpecs = {
            sportsCar: { 
                acceleration: 15, 
                maxSpeed: 150, 
                steering: 3.5, 
                color: 0xff00ff,
                secondaryColor: 0x00ffff, // Secondary color for details
                rimColor: 0xcccccc, // Color for wheel rims
                glassColor: 0x88ccff // Color for windows
            }
        };
        let themeSettings = {
            cyberpunk: { 
                groundColor: 0x0a0a0a,
                fogColor: 0x220033,
                fogDensity: 0.015,
                skyColor: 0x000033,
                ambientLight: 0x330066,
                directionalLight: 0xff00ff,
                
                neonColors: [
                    0xff00ff,
                    0x00ffff,
                    0xff3300,
                    0x33ff00
                ]
            }
        };
        const keys = {};
        let isMobileDevice = false;
        let joystickInput = 0; // Store joystick steering input (-1 to 1)
        
        // Environment objects
        let environmentObjects = [];

        // Object pooling for performance optimization
        const objectPool = {
            groundTileTextures: [],
            trackMaterials: [], // Add track material pooling
            
            getGroundTexture: function() {
                if (this.groundTileTextures.length > 0) {
                    return this.groundTileTextures.pop();
                }
                
                // Create a new texture if none are available in the pool
                const groundCanvas = document.createElement('canvas');
                groundCanvas.width = 512; // Reduced from 1024 for better performance
                groundCanvas.height = 512; // Reduced from 1024 for better performance
                const context = groundCanvas.getContext('2d');
                
                // Fill with dark color
                context.fillStyle = '#0a0a0a';
                context.fillRect(0, 0, groundCanvas.width, groundCanvas.height);
                
                // Add grid pattern
                context.strokeStyle = '#220022';
                context.lineWidth = 1;
                
                // Draw grid with larger spacing for better performance
                const gridSize = 128; // Increased from 64 for better performance
                for (let x = 0; x < groundCanvas.width; x += gridSize) {
                    context.beginPath();
                    context.moveTo(x, 0);
                    context.lineTo(x, groundCanvas.height);
                    context.stroke();
                }
                
                for (let y = 0; y < groundCanvas.height; y += gridSize) {
                    context.beginPath();
                    context.moveTo(0, y);
                    context.lineTo(groundCanvas.width, y);
                    context.stroke();
                }
                
                const groundTexture = new THREE.CanvasTexture(groundCanvas);
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(2, 2);
                
                return groundTexture;
            },
            
            returnGroundTexture: function(texture) {
                // Only keep a reasonable pool size to prevent memory issues
                if (this.groundTileTextures.length < 10) {
                    this.groundTileTextures.push(texture);
                } else {
                    texture.dispose();
                }
            },
            
            getTrackMaterial: function() {
                if (this.trackMaterials.length > 0) {
                    return this.trackMaterials.pop();
                }
                
                return createTrackMaterial();
            },
            
            returnTrackMaterial: function(material) {
                // Only keep a reasonable pool size to prevent memory issues
                if (this.trackMaterials.length < 5) {
                    this.trackMaterials.push(material);
                } else {
                    material.dispose();
                }
            }
        };

        // Initialize - make sure we only initialize once
        let initialized = false;
        function init() {
            // Create scene if it doesn't exist
            if (!scene) {
                scene = new THREE.Scene();
            }
            
            // Reset game state variables
            activePowerUp = null;
            powerUpTimer = 0;
            gameActive = false;
            
            // Create camera if it doesn't exist
            if (!camera) {
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            }
            
            // Create renderer if it doesn't exist
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
            }
            
            // Set up theme
            const themeConfig = themeSettings[theme];
            scene.background = new THREE.Color(themeConfig.skyColor);
            scene.fog = new THREE.FogExp2(themeConfig.fogColor, themeConfig.fogDensity);
            
            // Create camera
            camera.position.set(0, 5, -10);
            camera.lookAt(0, 0, 0);
            
            // Create orbit camera for development
            orbitCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            orbitCamera.position.set(15, 15, 15);
            orbitCamera.lookAt(0, 0, 0);
            
            // Add lights - updated for cyberpunk feel with increased brightness
            const ambientLight = new THREE.AmbientLight(themeConfig.ambientLight, 1.0); // Increased intensity
            scene.add(ambientLight);
            
            // Add a general hemisphere light for better overall illumination
            const hemisphereLight = new THREE.HemisphereLight(0x8844ff, 0x002244, 0.8);
            scene.add(hemisphereLight);
            
            const directionalLight = new THREE.DirectionalLight(themeConfig.directionalLight, 1.0); // Increased intensity
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Add more atmospheric lighting for cyberpunk theme
            addCyberpunkLighting();
            
            // Create car (after lighting setup)
            createCar();
            
            // Generate initial track
            generateInitialTrack();
            
            // Handle window resize and controls only once
            if (!initialized) {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('keydown', handleKeyDown);
                document.addEventListener('keyup', handleKeyUp);
                
                // Set up mobile controls
                setupMobileControls();
                
                // Check for device orientation
                checkOrientation();
                window.addEventListener('orientationchange', checkOrientation);
                window.addEventListener('resize', checkOrientation);
                
                // Create orbit controls (only for desktop)
                if (!isMobileDevice) {
                    orbitControls = new THREE.OrbitControls(orbitCamera, renderer.domElement);
                    orbitControls.enabled = false; // Disabled by default
                    orbitControls.enableDamping = true;
                    orbitControls.dampingFactor = 0.25;
                }
                
                initialized = true;
                
                // Start animation loop
                animate();
            }
            
            // Update UI visibility based on game state
            updateUIVisibility();
        }
        
        // Function to check device orientation and show/hide portrait message
        function checkOrientation() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isMobile && isPortrait) {
                document.getElementById('portraitMessage').style.display = 'flex';
            } else {
                document.getElementById('portraitMessage').style.display = 'none';
            }
        }
        
        // Function to update UI visibility based on game state
        function updateUIVisibility() {
            // Show/hide game UI elements based on game state
            const uiElement = document.getElementById('ui');
            const versionElement = document.getElementById('version');
            
            if (gameActive) {
                uiElement.style.display = 'block';
                versionElement.style.display = 'none';
            } else {
                uiElement.style.display = 'none';
                versionElement.style.display = 'block';
            }
        }
        
        function createCar() {
            const specs = carSpecs[carType];
            acceleration = specs.acceleration;
            maxSpeed = specs.maxSpeed;
            steering = specs.steering;
            
            // Create a group to hold all car parts
            car = new THREE.Group();
            
            // Main body dimensions
            const bodyWidth = 2;
            const bodyHeight = 0.8;
            const bodyLength = 4.5;
            
            // Create main body (lower part)
            const bodyGeometry = new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyLength);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: specs.color,
                emissive: specs.color,
                emissiveIntensity: 0.2,
                shininess: 80
            });
            const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            bodyMesh.position.y = 0.5;
            bodyMesh.castShadow = true;
            bodyMesh.receiveShadow = true;
            car.add(bodyMesh);
            
            // Create upper body (cabin)
            const cabinGeometry = new THREE.BoxGeometry(bodyWidth * 0.8, bodyHeight * 0.7, bodyLength * 0.5);
            const cabinMaterial = new THREE.MeshPhongMaterial({ 
                color: specs.color,
                emissive: specs.color,
                emissiveIntensity: 0.2,
                shininess: 80
            });
            const cabinMesh = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabinMesh.position.y = bodyHeight + 0.4;
            cabinMesh.position.z = -0.2; // Slightly toward the back
            cabinMesh.castShadow = true;
            cabinMesh.receiveShadow = true;
            car.add(cabinMesh);
            
            // Create windshield
            const windshieldGeometry = new THREE.BoxGeometry(bodyWidth * 0.75, bodyHeight * 0.6, 0.1);
            const glassMaterial = new THREE.MeshPhongMaterial({ 
                color: specs.glassColor,
                transparent: true,
                opacity: 0.7,
                shininess: 100
            });
            const windshieldMesh = new THREE.Mesh(windshieldGeometry, glassMaterial);
            windshieldMesh.position.y = bodyHeight + 0.4;
            windshieldMesh.position.z = bodyLength * 0.1;
            windshieldMesh.rotation.x = Math.PI * 0.1; // Slight angle
            car.add(windshieldMesh);
            
            // Create rear window
            const rearWindowGeometry = new THREE.BoxGeometry(bodyWidth * 0.75, bodyHeight * 0.5, 0.1);
            const rearWindowMesh = new THREE.Mesh(rearWindowGeometry, glassMaterial);
            rearWindowMesh.position.y = bodyHeight + 0.4;
            rearWindowMesh.position.z = -bodyLength * 0.25;
            rearWindowMesh.rotation.x = -Math.PI * 0.1; // Slight angle
            car.add(rearWindowMesh);
            
            // Create spoiler
            const spoilerWidth = bodyWidth * 0.9;
            const spoilerHeight = 0.1;
            const spoilerLength = 0.5;
            const spoilerGeometry = new THREE.BoxGeometry(spoilerWidth, spoilerHeight, spoilerLength);
            const spoilerMaterial = new THREE.MeshPhongMaterial({ 
                color: specs.secondaryColor,
                emissive: specs.secondaryColor,
                emissiveIntensity: 0.5,
                shininess: 80
            });
            const spoilerMesh = new THREE.Mesh(spoilerGeometry, spoilerMaterial);
            spoilerMesh.position.y = bodyHeight + 0.7;
            spoilerMesh.position.z = -bodyLength / 2 + 0.1;
            car.add(spoilerMesh);
            
            // Create spoiler supports
            const supportGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
            const supportMaterial = new THREE.MeshPhongMaterial({ color: specs.secondaryColor });
            
            const leftSupport = new THREE.Mesh(supportGeometry, supportMaterial);
            leftSupport.position.set(-spoilerWidth / 2 + 0.2, bodyHeight + 0.5, -bodyLength / 2 + 0.1);
            car.add(leftSupport);
            
            const rightSupport = new THREE.Mesh(supportGeometry, supportMaterial);
            rightSupport.position.set(spoilerWidth / 2 - 0.2, bodyHeight + 0.5, -bodyLength / 2 + 0.1);
            car.add(rightSupport);
            
            // Create front lights
            const lightGeometry = new THREE.BoxGeometry(0.4, 0.2, 0.1);
            const leftLightMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xffffff,
                emissive: 0xffffcc,
                emissiveIntensity: 1.0
            });
            
            const leftFrontLight = new THREE.Mesh(lightGeometry, leftLightMaterial);
            leftFrontLight.position.set(-bodyWidth / 2 + 0.3, 0.5, bodyLength / 2);
            car.add(leftFrontLight);
            
            const rightFrontLight = new THREE.Mesh(lightGeometry, leftLightMaterial);
            rightFrontLight.position.set(bodyWidth / 2 - 0.3, 0.5, bodyLength / 2);
            car.add(rightFrontLight);
            
            // Create rear lights
            const rearLightMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1.0
            });
            
            const leftRearLight = new THREE.Mesh(lightGeometry, rearLightMaterial);
            leftRearLight.position.set(-bodyWidth / 2 + 0.3, 0.5, -bodyLength / 2);
            car.add(leftRearLight);
            
            const rightRearLight = new THREE.Mesh(lightGeometry, rearLightMaterial);
            rightRearLight.position.set(bodyWidth / 2 - 0.3, 0.5, -bodyLength / 2);
            car.add(rightRearLight);
            
            // Create exhaust pipes
            const exhaustGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.3, 8);
            exhaustGeometry.rotateX(Math.PI / 2);
            const exhaustMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                emissive: 0x333333,
                emissiveIntensity: 0.2
            });
            
            const leftExhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            leftExhaust.position.set(-bodyWidth / 2 + 0.4, 0.3, -bodyLength / 2 - 0.1);
            car.add(leftExhaust);
            
            const rightExhaust = new THREE.Mesh(exhaustGeometry, exhaustMaterial);
            rightExhaust.position.set(bodyWidth / 2 - 0.4, 0.3, -bodyLength / 2 - 0.1);
            car.add(rightExhaust);
            
            // Create wheels with rims
            const wheelRadius = 0.5;
            const wheelThickness = 0.3;
            
            // Create wheel geometries
            const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelThickness, 16);
            wheelGeometry.rotateZ(Math.PI / 2);
            
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const rimMaterial = new THREE.MeshPhongMaterial({ 
                color: specs.rimColor,
                shininess: 100
            });
            
            // Create rim geometry
            const rimGeometry = new THREE.TorusGeometry(wheelRadius * 0.7, wheelRadius * 0.1, 8, 16);
            
            // Front left wheel group
            const frontLeftWheel = new THREE.Group();
            const frontLeftWheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontLeftWheel.add(frontLeftWheelMesh);
            
            // Add rim to front left wheel
            const frontLeftRim = new THREE.Mesh(rimGeometry, rimMaterial);
            frontLeftRim.rotation.y = Math.PI / 2;
            frontLeftWheel.add(frontLeftRim);
            
            frontLeftWheel.position.set(-bodyWidth / 2 - wheelThickness / 2, wheelRadius, bodyLength / 2 - wheelRadius);
            frontLeftWheel.name = 'frontLeftWheel';
            car.add(frontLeftWheel);
            
            // Front right wheel group
            const frontRightWheel = new THREE.Group();
            const frontRightWheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontRightWheel.add(frontRightWheelMesh);
            
            // Add rim to front right wheel
            const frontRightRim = new THREE.Mesh(rimGeometry, rimMaterial);
            frontRightRim.rotation.y = Math.PI / 2;
            frontRightWheel.add(frontRightRim);
            
            frontRightWheel.position.set(bodyWidth / 2 + wheelThickness / 2, wheelRadius, bodyLength / 2 - wheelRadius);
            frontRightWheel.name = 'frontRightWheel';
            car.add(frontRightWheel);
            
            // Rear left wheel group
            const rearLeftWheel = new THREE.Group();
            const rearLeftWheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rearLeftWheel.add(rearLeftWheelMesh);
            
            // Add rim to rear left wheel
            const rearLeftRim = new THREE.Mesh(rimGeometry, rimMaterial);
            rearLeftRim.rotation.y = Math.PI / 2;
            rearLeftWheel.add(rearLeftRim);
            
            rearLeftWheel.position.set(-bodyWidth / 2 - wheelThickness / 2, wheelRadius, -bodyLength / 2 + wheelRadius);
            rearLeftWheel.name = 'rearLeftWheel';
            car.add(rearLeftWheel);
            
            // Rear right wheel group
            const rearRightWheel = new THREE.Group();
            const rearRightWheelMesh = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rearRightWheel.add(rearRightWheelMesh);
            
            // Add rim to rear right wheel
            const rearRightRim = new THREE.Mesh(rimGeometry, rimMaterial);
            rearRightRim.rotation.y = Math.PI / 2;
            rearRightWheel.add(rearRightRim);
            
            rearRightWheel.position.set(bodyWidth / 2 + wheelThickness / 2, wheelRadius, -bodyLength / 2 + wheelRadius);
            rearRightWheel.name = 'rearRightWheel';
            car.add(rearRightWheel);
            
            // Add neon underglow
            const glowGeometry = new THREE.PlaneGeometry(bodyWidth * 1.2, bodyLength * 1.1);
            glowGeometry.rotateX(-Math.PI / 2);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: specs.color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            glowMesh.position.y = 0.05;
            car.add(glowMesh);
            
            // Set car position
            car.position.set(0, 0, 0);
            car.rotation.y = 0;
            
            // Initialize steering properties
            car.currentSteeringAngle = 0;
            
            // Add car to scene
            scene.add(car);
            
            // Ensure no shield or nitro effects are present
            const shield = car.getObjectByName('shield');
            if (shield) {
                car.remove(shield);
                shield.geometry.dispose();
                shield.material.dispose();
            }
            
            const nitroEffect = car.getObjectByName('nitroEffect');
            if (nitroEffect) {
                car.remove(nitroEffect);
                nitroEffect.children.forEach(child => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        child.material.dispose();
                    }
                });
            }
            
            // Find and update the spotlight to target the car after it's created
            environmentObjects.forEach(obj => {
                if (obj.type === 'spotlight' && obj.mesh) {
                    obj.mesh.target = car;
                }
            });
        }
        
        function addCyberpunkLighting() {
            // Add point lights with neon colors along the track
            const themeConfig = themeSettings[theme];
            
            // Add a pulsing global light with increased range and intensity
            const pulsingLight = new THREE.PointLight(0xff00ff, 1.5, 200); // Increased intensity and range
            pulsingLight.position.set(0, 30, 0);
            pulsingLight.userData = { 
                phase: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random() * 0.5,
                initialIntensity: 1.5
            };
            scene.add(pulsingLight);
            
            // Create a brighter spotlight to follow the car (initialized with safe position before car is created)
            const spotlight = new THREE.SpotLight(0x00ffff, 1.5, 100, Math.PI / 6, 0.5); // Increased intensity and range
            spotlight.position.set(0, 20, -5);
            // Will set spotlight target to car later when car is available
            spotlight.castShadow = true;
            scene.add(spotlight);
            
            // Add 4 more point lights around the starting area for initial visibility
            const colors = themeConfig.neonColors;
            
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const x = Math.sin(angle) * 20;
                const z = Math.cos(angle) * 20;
                
                const pointLight = new THREE.PointLight(colors[i], 1.0, 50);
                pointLight.position.set(x, 5, z);
                scene.add(pointLight);
                
                environmentObjects.push({
                    type: 'staticLight',
                    mesh: pointLight,
                    segment: 0 // Attach to first segment
                });
            }
            
            // Store these lights for animation
            environmentObjects.push({ 
                type: 'pulsingLight', 
                mesh: pulsingLight 
            });
            
            environmentObjects.push({ 
                type: 'spotlight', 
                mesh: spotlight 
            });
        }
        
        function generateInitialTrack() {
            // Create initial ground tiles instead of a single large plane
            createInitialGroundTiles();
            
            // Generate first few track segments
            for (let i = 0; i < 10; i++) {
                addTrackSegment();
            }
        }
        
        function createInitialGroundTiles() {
            // Create the initial set of ground tiles around the starting area
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    createGroundTile(x * groundTileSize, z * groundTileSize);
                }
            }
        }
        
        function createGroundTile(centerX, centerZ) {
            // Create a ground tile centered at the given position
            const groundGeometry = new THREE.PlaneGeometry(groundTileSize, groundTileSize);
            
            // Use texture from object pool for better performance
            const groundTexture = objectPool.getGroundTexture();
            
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: themeSettings[theme].groundColor,
                map: groundTexture,
                side: THREE.DoubleSide,
                emissive: 0x110022,
                emissiveIntensity: 0.1
            });
            
            const groundTile = new THREE.Mesh(groundGeometry, groundMaterial);
            
            // Use quaternion for ground rotation to maintain consistency with track segments
            const groundRotation = new THREE.Quaternion();
            groundRotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
            groundTile.quaternion.copy(groundRotation);
            
            // Position the ground tile at the specified center
            groundTile.position.set(centerX, 0, centerZ);
            
            groundTile.receiveShadow = true;
            scene.add(groundTile);
            
            // Store the ground tile reference
            groundTiles.push({
                mesh: groundTile,
                x: centerX,
                z: centerZ,
                texture: groundTexture // Store reference to return to pool later
            });
            
            return groundTile;
        }
        
        function addTrackSegment() {
            // Always create straight segments only
            const segmentType = 'straight';
            
            let lastPoint = { x: 0, z: 0 };
            let lastRotation = 0;
            
            if (track.length > 0) {
                const lastSegment = track[track.length - 1];
                lastPoint = { x: lastSegment.end.x, z: lastSegment.end.z };
                lastRotation = lastSegment.endRotation;
            }
            
            // Use a global sequentialSegmentId to keep sequential numbering even as segments are removed
            if (typeof window.sequentialSegmentId === 'undefined') {
                window.sequentialSegmentId = 0;
            }
            
            const segment = {
                start: { x: lastPoint.x, z: lastPoint.z },
                startRotation: lastRotation,
                type: segmentType,
                segment: window.sequentialSegmentId++, // Use the sequential ID instead of array length
                arrayIndex: track.length // Store the initial array index separately
            };
            
            // Create the straight track segment
            segment.end = {
                x: lastPoint.x + segmentLength * Math.sin(lastRotation),
                z: lastPoint.z + segmentLength * Math.cos(lastRotation)
            };
            segment.endRotation = lastRotation;
            
            // Create the straight track segment
            const trackGeometry = new THREE.PlaneGeometry(trackWidth * 1.2, segmentLength * 1.15); // Increase width and length for better coverage
            // Get material from pool for better performance
            const trackMaterial = objectPool.getTrackMaterial();
            
            const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
            
            // Position at the midpoint between start and end
            trackMesh.position.set(
                (segment.start.x + segment.end.x) / 2,
                0.02, // Slight elevation to prevent z-fighting
                (segment.start.z + segment.end.z) / 2
            );
            
            // Use quaternions for rotation
            const flatRotation = new THREE.Quaternion();
            flatRotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
            
            const directionRotation = new THREE.Quaternion();
            directionRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), segment.startRotation);
            
            // Apply rotations in the correct order: first direction, then flatten
            trackMesh.quaternion.copy(flatRotation);
            trackMesh.quaternion.premultiply(directionRotation);
            
            scene.add(trackMesh);
            // Store track material reference for cleanup
            segment.mesh = trackMesh;
            segment.material = trackMaterial;
            
            // Add environment objects on the sides of the straight track
            if (Math.random() < 0.7) {
                addEnvironmentObject(segment, 'building');
            }
            
            if (Math.random() < 0.6) {
                addEnvironmentObject(segment, 'tree');
            }
            
            if (Math.random() < 0.4) {
                addEnvironmentObject(segment, 'debris');
            }
            
            track.push(segment);
            
            // Add random obstacles and power-ups on this segment, but avoid the start
            const isFirstSegment = track.length === 1;
            
            // Don't add obstacles on the first few segments to give player time to adjust
            if (!isFirstSegment && track.length > 3 && Math.random() < 0.4) {
                addObstacle(segment);
            }
            
            // Add power-ups, but less frequently and not on the first few segments
            // Increase the minimum track length to prevent power-ups from appearing too early
            if (!isFirstSegment && track.length > 10 && Math.random() < 0.3) {
                addPowerUp(segment);
            }
            
            // After adding a track segment, check if we need to add ground tiles
            checkAndCreateGroundTiles();
            
            // Add street lights along the track
            if (Math.random() < 0.4) {
                addStreetLight(segment);
            }
            
            // Add cyberpunk billboards
            if (Math.random() < 0.3) {
                addCyberpunkBillboard(segment, true);
            }
            
            // Add holographic advertisements
            if (Math.random() < 0.2) {
                addHolographicAd(segment, true);
            }
            
            // Add city roads branching from the main track
            addCityRoad(segment);
        }
        
        function checkAndCreateGroundTiles() {
            if (track.length === 0) return;
            
            // Get the end point of the latest track segment
            const latestSegment = track[track.length - 1];
            const endX = latestSegment.end.x;
            const endZ = latestSegment.end.z;
            
            // Create all ground tiles in a larger area around the latest track segment
            // This ensures more complete coverage without gaps
            const baseTileX = Math.floor(endX / groundTileSize) * groundTileSize;
            const baseTileZ = Math.floor(endZ / groundTileSize) * groundTileSize;
            
            // Get direction of travel to determine "right" and "left" sides
            let dirX = 0, dirZ = 1; // Default direction (forward)
            
            if (track.length >= 2) {
                const prevSegment = track[track.length - 2];
                dirX = latestSegment.end.x - prevSegment.end.x;
                dirZ = latestSegment.end.z - prevSegment.end.z;
                // Normalize
                const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
                if (dirLength > 0) {
                    dirX /= dirLength;
                    dirZ /= dirLength;
                }
            }
            
            // Calculate right side vector (perpendicular to direction)
            const rightX = -dirZ;
            const rightZ = dirX;
            
            // Create a larger grid of tiles around the track point
            // Extended more on the right side and ahead
            for (let xOffset = -2; xOffset <= 3; xOffset++) {
                for (let zOffset = -2; zOffset <= 3; zOffset++) {
                    const tileX = baseTileX + xOffset * groundTileSize + groundTileSize / 2;
                    const tileZ = baseTileZ + zOffset * groundTileSize + groundTileSize / 2;
                    
                    // Use a more reliable way to check if a tile exists at this position
                    let tileExists = false;
                    for (let i = 0; i < groundTiles.length; i++) {
                        const tile = groundTiles[i];
                        // Use a very small epsilon for floating point comparison
                        if (Math.abs(tile.x - tileX) < 0.1 && Math.abs(tile.z - tileZ) < 0.1) {
                            tileExists = true;
                            break;
                        }
                    }
                    
                    if (!tileExists) {
                        createGroundTile(tileX, tileZ);
                    }
                }
            }
            
            // Create extra tiles specifically on the right side relative to the car's direction
            // This ensures better coverage on the problematic side
            for (let i = 1; i <= 3; i++) {
                const extraRightX = baseTileX + (rightX * i * groundTileSize) + groundTileSize / 2;
                const extraRightZ = baseTileZ + (rightZ * i * groundTileSize) + groundTileSize / 2;
                
                let rightTileExists = false;
                for (let j = 0; j < groundTiles.length; j++) {
                    const tile = groundTiles[j];
                    if (Math.abs(tile.x - extraRightX) < 0.1 && Math.abs(tile.z - extraRightZ) < 0.1) {
                        rightTileExists = true;
                        break;
                    }
                }
                
                if (!rightTileExists) {
                    createGroundTile(extraRightX, extraRightZ);
                    
                    // Add surrounding tiles for the extra right tiles too
                    for (let xOffset = -1; xOffset <= 1; xOffset++) {
                        for (let zOffset = -1; zOffset <= 1; zOffset++) {
                            if (xOffset === 0 && zOffset === 0) continue; // Skip center we just created
                            
                            const surroundX = extraRightX + xOffset * groundTileSize;
                            const surroundZ = extraRightZ + zOffset * groundTileSize;
                            
                            let surroundExists = false;
                            for (let k = 0; k < groundTiles.length; k++) {
                                const tile = groundTiles[k];
                                if (Math.abs(tile.x - surroundX) < 0.1 && Math.abs(tile.z - surroundZ) < 0.1) {
                                    surroundExists = true;
                                    break;
                                }
                            }
                            
                            if (!surroundExists) {
                                createGroundTile(surroundX, surroundZ);
                            }
                        }
                    }
                }
            }
            
            // Also create tiles at the midpoint between current segment and previous segment
            // This helps ensure continuous coverage along the track
            if (track.length > 1) {
                const prevSegment = track[track.length - 2];
                const midX = (prevSegment.end.x + latestSegment.end.x) / 2;
                const midZ = (prevSegment.end.z + latestSegment.end.z) / 2;
                
                const midTileX = Math.floor(midX / groundTileSize) * groundTileSize + groundTileSize / 2;
                const midTileZ = Math.floor(midZ / groundTileSize) * groundTileSize + groundTileSize / 2;
                
                // Check if a tile exists at the midpoint
                let midTileExists = false;
                for (let i = 0; i < groundTiles.length; i++) {
                    const tile = groundTiles[i];
                    if (Math.abs(tile.x - midTileX) < 0.1 && Math.abs(tile.z - midTileZ) < 0.1) {
                        midTileExists = true;
                        break;
                    }
                }
                
                if (!midTileExists) {
                    createGroundTile(midTileX, midTileZ);
                    
                    // Also create tiles around the midpoint for better coverage
                    for (let xOffset = -2; xOffset <= 2; xOffset++) {
                        for (let zOffset = -2; zOffset <= 2; zOffset++) {
                            if (xOffset === 0 && zOffset === 0) continue; // Skip the center tile we just created
                            
                            const tileX = midTileX + xOffset * groundTileSize;
                            const tileZ = midTileZ + zOffset * groundTileSize;
                            
                            let surroundTileExists = false;
                            for (let i = 0; i < groundTiles.length; i++) {
                                const tile = groundTiles[i];
                                if (Math.abs(tile.x - tileX) < 0.1 && Math.abs(tile.z - tileZ) < 0.1) {
                                    surroundTileExists = true;
                                    break;
                                }
                            }
                            
                            if (!surroundTileExists) {
                                createGroundTile(tileX, tileZ);
                            }
                        }
                    }
                }
            }
            
            // Generate extra ground tiles based on the car's position too
            // This ensures we have ground coverage where the player actually is
            if (car) {
                const carX = car.position.x;
                const carZ = car.position.z;
                
                const carBaseTileX = Math.floor(carX / groundTileSize) * groundTileSize;
                const carBaseTileZ = Math.floor(carZ / groundTileSize) * groundTileSize;
                
                // Create tiles in a grid around the car
                for (let xOffset = -2; xOffset <= 2; xOffset++) {
                    for (let zOffset = -2; zOffset <= 2; zOffset++) {
                        const tileX = carBaseTileX + xOffset * groundTileSize + groundTileSize / 2;
                        const tileZ = carBaseTileZ + zOffset * groundTileSize + groundTileSize / 2;
                        
                        let tileExists = false;
                        for (let i = 0; i < groundTiles.length; i++) {
                            const tile = groundTiles[i];
                            if (Math.abs(tile.x - tileX) < 0.1 && Math.abs(tile.z - tileZ) < 0.1) {
                                tileExists = true;
                                break;
                            }
                        }
                        
                        if (!tileExists) {
                            createGroundTile(tileX, tileZ);
                        }
                    }
                }
            }
        }
        
        function addObstacle(segment) {
            // Create a variety of cyberpunk-themed obstacles
            const obstacleType = Math.floor(Math.random() * 4); // 4 different obstacle types
            let obstacle;
            
            // Use one of the neon colors for accents
            const neonColors = themeSettings[theme].neonColors;
            const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            
            if (obstacleType === 0) {
                // Type 1: Cyberpunk barrier/roadblock
                obstacle = new THREE.Group();
                
                // Create the base
                const baseGeometry = new THREE.BoxGeometry(3, 0.5, 1);
                const baseMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x333333,
                    emissive: 0x111111
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.25;
                obstacle.add(base);
                
                // Create vertical barriers with neon stripes
                for (let i = 0; i < 2; i++) {
                    const barrierGeometry = new THREE.BoxGeometry(0.5, 2, 0.5);
                    const barrierMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x222222
                    });
                    const barrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                    
                    // Position on either end of the base
                    barrier.position.set((i === 0 ? -1 : 1) * 1.25, 1.25, 0);
                    obstacle.add(barrier);
                    
                    // Add neon stripe
                    const stripeGeometry = new THREE.BoxGeometry(0.1, 2, 0.6);
                    const stripeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x111111,
                        emissive: neonColor,
                        emissiveIntensity: 0.8
                    });
                    const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
                    stripe.position.set((i === 0 ? -1 : 1) * 1.25 + 0.3, 1.25, 0);
                    obstacle.add(stripe);
                }
                
                // Add a horizontal bar connecting the barriers
                const barGeometry = new THREE.BoxGeometry(3, 0.3, 0.3);
                const barMaterial = new THREE.MeshPhongMaterial({
                    color: 0x111111,
                    emissive: neonColor,
                    emissiveIntensity: 0.6
                });
                const bar = new THREE.Mesh(barGeometry, barMaterial);
                bar.position.y = 2.0;
                obstacle.add(bar);
                
            } else if (obstacleType === 1) {
                // Type 2: Holographic warning barrier
                obstacle = new THREE.Group();
                
                // Create base emitter
                const baseGeometry = new THREE.CylinderGeometry(0.5, 0.7, 0.8, 8);
                const baseMaterial = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    emissive: neonColor,
                    emissiveIntensity: 0.3
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = 0.4;
                obstacle.add(base);
                
                // Create holographic warning panels
                const panelCount = 3;
                for (let i = 0; i < panelCount; i++) {
                    const panelGeometry = new THREE.PlaneGeometry(2, 1.5);
                    const panelMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff0000,
                        emissive: 0xff0000,
                        emissiveIntensity: 0.7,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    const angle = (i / panelCount) * Math.PI * 2;
                    panel.position.set(
                        Math.sin(angle) * 0.5,
                        1.5,
                        Math.cos(angle) * 0.5
                    );
                    
                    // Rotate panel to face outward
                    panel.rotation.y = angle;
                    
                    // Add animation data
                    panel.userData = {
                        rotationSpeed: 0.5,
                        pulseSpeed: 1.0 + Math.random() * 0.5,
                        time: Math.random() * Math.PI * 2
                    };
                    
                    obstacle.add(panel);
                }
                
                // Add animation data to the obstacle
                obstacle.userData = {
                    type: 'holographicBarrier',
                    animationTime: 0
                };
                
            } else if (obstacleType === 2) {
                // Type 3: Damaged vehicle/drone
                obstacle = new THREE.Group();
                
                // Create main body
                const bodyGeometry = new THREE.BoxGeometry(2, 0.8, 3);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x444444,
                    emissive: 0xff3300,
                    emissiveIntensity: 0.2
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                obstacle.add(body);
                
                // Add damaged parts and details
                const detailsCount = 3 + Math.floor(Math.random() * 3);
                for (let i = 0; i < detailsCount; i++) {
                    // Random detail type
                    if (Math.random() > 0.5) {
                        // Add a panel/wing
                        const panelGeometry = new THREE.BoxGeometry(1 + Math.random(), 0.2, 1 + Math.random());
                        const panelMaterial = new THREE.MeshPhongMaterial({
                            color: 0x333333
                        });
                        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                        
                        // Position at random offset from body
                        panel.position.set(
                            (Math.random() - 0.5) * 2.5,
                            0.5 + Math.random() * 0.8,
                            (Math.random() - 0.5) * 3.5
                        );
                        
                        // Random rotation to look damaged
                        panel.rotation.set(
                            Math.random() * Math.PI * 0.5,
                            Math.random() * Math.PI * 2,
                            Math.random() * Math.PI * 0.5
                        );
                        
                        obstacle.add(panel);
                    } else {
                        // Add a damaged light/component
                        const lightGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.2, 8, 8);
                        const lightMaterial = new THREE.MeshPhongMaterial({
                            color: 0x222222,
                            emissive: Math.random() > 0.5 ? 0xff0000 : neonColor,
                            emissiveIntensity: 0.3 + Math.random() * 0.7
                        });
                        const light = new THREE.Mesh(lightGeometry, lightMaterial);
                        
                        // Position on the body
                        light.position.set(
                            (Math.random() - 0.5) * 1.8,
                            1.0 + Math.random() * 0.5,
                            (Math.random() - 0.5) * 2.8
                        );
                        
                        // Add animation data for flickering
                        light.userData = {
                            flickerSpeed: 3 + Math.random() * 5,
                            time: Math.random() * Math.PI * 2,
                            originalIntensity: lightMaterial.emissiveIntensity
                        };
                        
                        obstacle.add(light);
                    }
                }
                
                // Add animation data to the obstacle
                obstacle.userData = {
                    type: 'damagedVehicle',
                    animationTime: 0
                };
                
            } else {
                // Type 4: Tech debris/crates
                obstacle = new THREE.Group();
                
                // Create a stack of crates/containers
                const crateCount = 2 + Math.floor(Math.random() * 3);
                for (let i = 0; i < crateCount; i++) {
                    const crateSize = 1 + Math.random() * 0.5;
                    const crateGeometry = new THREE.BoxGeometry(
                        crateSize,
                        crateSize,
                        crateSize
                    );
                    
                    // Alternate between dark crates and neon-accented ones
                    const crateMaterial = new THREE.MeshPhongMaterial({
                        color: 0x222222,
                        emissive: i % 2 === 0 ? 0x000000 : neonColor,
                        emissiveIntensity: 0.4
                    });
                    
                    const crate = new THREE.Mesh(crateGeometry, crateMaterial);
                    
                    // Stack crates with slight offsets
                    crate.position.set(
                        (Math.random() - 0.5) * 1.0,
                        crateSize / 2 + (i * crateSize * 0.8),
                        (Math.random() - 0.5) * 1.0
                    );
                    
                    // Random slight rotation
                    crate.rotation.set(
                        Math.random() * 0.2,
                        Math.random() * Math.PI * 2,
                        Math.random() * 0.2
                    );
                    
                    obstacle.add(crate);
                    
                    // Add neon edges to some crates
                    if (Math.random() > 0.5) {
                        const edgeGeometry = new THREE.BoxGeometry(
                            crateSize + 0.05,
                            0.05,
                            0.05
                        );
                        const edgeMaterial = new THREE.MeshPhongMaterial({
                            color: 0x000000,
                            emissive: neonColor,
                            emissiveIntensity: 0.8
                        });
                        
                        // Add edges at random positions
                        for (let j = 0; j < 2; j++) {
                            const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
                            edge.position.set(
                                0,
                                (j === 0 ? -1 : 1) * (crateSize / 2 - 0.05),
                                (Math.random() - 0.5) * (crateSize - 0.2)
                            );
                            crate.add(edge);
                        }
                    }
                }
            }
            
            // Calculate track direction
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            
            // Normalize direction
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Calculate position along track (between 10-90%)
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Calculate lateral offset (stay within track width)
            const lateralOffset = (Math.random() - 0.5) * trackWidth * 0.6;
            
            // Calculate final position
            const posX = segment.start.x + dirX * alongTrack + perpX * lateralOffset;
            const posZ = segment.start.z + dirZ * alongTrack + perpZ * lateralOffset;
            
            obstacle.position.set(posX, 0, posZ);
            
            // Rotate obstacle to face random direction
            obstacle.rotation.y = Math.random() * Math.PI * 2;
            
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            
            // Apply shadow settings to all children
            obstacle.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            scene.add(obstacle);
            
            obstacles.push({
                mesh: obstacle,
                segment: track.length - 1,
                collided: false
            });
        }
        
        function addPowerUp(segment) {
            const types = ['speed', 'shield', 'nitro'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            let geometry, material;
            
            // Create more distinctive shapes for each power-up type
            if (type === 'speed') {
                // Arrow/cone shape for speed boost
                geometry = new THREE.ConeGeometry(0.7, 2, 16);
                material = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5,
                    shininess: 100
                });
                // Rotate to point upward
                geometry.rotateX(Math.PI);
            } else if (type === 'shield') {
                // Ring/torus shape for shield
                geometry = new THREE.TorusGeometry(1, 0.3, 16, 32);
                material = new THREE.MeshPhongMaterial({ 
                    color: 0x0088ff,
                    emissive: 0x0044ff,
                    emissiveIntensity: 0.5,
                    shininess: 100
                });
            } else {
                // Crystal/octahedron shape for nitro
                geometry = new THREE.OctahedronGeometry(0.8, 0);
                material = new THREE.MeshPhongMaterial({ 
                    color: 0xffcc00,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.5,
                    shininess: 100
                });
            }
            
            const powerUp = new THREE.Mesh(geometry, material);
            
            // Calculate track direction
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            
            // Normalize direction
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Calculate position along track (between 10-90%)
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Calculate lateral offset (stay within track width)
            const lateralOffset = (Math.random() - 0.5) * trackWidth * 0.6;
            
            // Calculate final position
            const posX = segment.start.x + dirX * alongTrack + perpX * lateralOffset;
            const posZ = segment.start.z + dirZ * alongTrack + perpZ * lateralOffset;
            
            powerUp.position.set(posX, 1, posZ);
            scene.add(powerUp);
            
            // Add some rotation animation
            powerUp.userData.rotationSpeed = 0.03;
            powerUp.userData.floatSpeed = 0.02;
            powerUp.userData.floatHeight = 0.5;
            powerUp.userData.baseY = 1;
            powerUp.userData.time = Math.random() * Math.PI * 2;
            powerUp.userData.type = type; // Store the type for reference
            
            powerUps.push({
                mesh: powerUp,
                type: type,
                segment: track.length - 1,
                collected: false
            });
        }
        
        function updateCar(delta) {
            // Handle inputs
            let moveForward = keys['w'] || keys['arrowup'];
            let moveBackward = keys['s'] || keys['arrowdown'];
            let turnLeft = keys['a'] || keys['arrowleft'];
            let turnRight = keys['d'] || keys['arrowright'];
            
            // Update speed based on inputs
            if (moveForward) {
                speed += acceleration * delta;
            } else if (moveBackward) {
                speed -= acceleration * 1.5 * delta;
            } else {
                // Apply friction to slow down
                speed *= 0.98;
            }
            
            // Apply active power-up effects
            if (activePowerUp === 'speed') {
                // Speed boost increases top speed but acceleration is normal
                speed = Math.min(speed, maxSpeed * 1.2);
            } else if (activePowerUp === 'nitro') {
                // Nitro provides immediate acceleration boost
                speed += acceleration * 3 * delta; // Strong acceleration boost
                speed = Math.min(speed, maxSpeed * 1.5); // Higher top speed cap
            } else {
                speed = Math.min(speed, maxSpeed);
            }
            
            speed = Math.max(speed, -maxSpeed / 2); // Limit reverse speed
            speed = Math.min(speed, maxSpeed * 1.5); // Hard cap to prevent insane speeds
            
            // Update steering based on inputs - improved steering model
            let targetSteeringAngle = 0;
            const maxSteeringAngle = 0.8; // Maximum steering angle in radians (about 45 degrees)
            const steeringSpeed = steering * 2.5; // How quickly steering responds
            
            // Calculate target steering angle based on inputs
            if (turnLeft) targetSteeringAngle = maxSteeringAngle;
            if (turnRight) targetSteeringAngle = -maxSteeringAngle;
            
            // Handle joystick steering for mobile
            if (joystickInput !== 0) {
                targetSteeringAngle = maxSteeringAngle * -joystickInput;
            }
            
            // Apply speed-sensitive steering (less responsive at high speeds)
            const speedFactor = 1 - (Math.min(speed, maxSpeed) / maxSpeed) * 0.5;
            const effectiveSteeringSpeed = steeringSpeed * speedFactor;
            
            // Smoothly interpolate current steering angle towards target
            if (Math.abs(car.currentSteeringAngle - targetSteeringAngle) > 0.01) {
                car.currentSteeringAngle += (targetSteeringAngle - car.currentSteeringAngle) * effectiveSteeringSpeed * delta;
            } else {
                car.currentSteeringAngle = targetSteeringAngle;
            }
            
            // Calculate effective steering angle (limited by speed)
            const effectiveSteeringAngle = car.currentSteeringAngle * speedFactor;
            
            // Calculate turning radius based on steering angle
            let turningRadius = 9999; // Default to nearly straight
            const minTurningRadius = 5; // Minimum turning radius
            
            if (Math.abs(effectiveSteeringAngle) > 0.01) {
                turningRadius = minTurningRadius / Math.sin(Math.abs(effectiveSteeringAngle));
            } else {
                turningRadius = 9999; // Nearly infinite for straight driving
            }
            
            // Calculate car's movement based on bicycle model (simplified car physics)
            // This model treats the car as having a front and rear axle with the front axle steering
            const wheelbase = 3; // Distance between front and rear axle
            
            if (Math.abs(effectiveSteeringAngle) > 0.01) {
                // Calculate angular velocity based on speed and turning radius
                const angularVelocity = (speed / turningRadius) * Math.sign(effectiveSteeringAngle);
                
                // Update car's rotation
                car.rotation.y += angularVelocity * delta;
            }
            
            // Move car forward in the direction it's facing
            const movement = speed * delta;
            car.position.x += Math.sin(car.rotation.y) * movement;
            car.position.z += Math.cos(car.rotation.y) * movement;
            
            // Rotate wheels based on speed and steering
            const frontLeftWheel = car.getObjectByName('frontLeftWheel');
            const frontRightWheel = car.getObjectByName('frontRightWheel');
            const rearLeftWheel = car.getObjectByName('rearLeftWheel');
            const rearRightWheel = car.getObjectByName('rearRightWheel');
            
            // Rotate wheels forward based on speed
            const wheelRotationSpeed = speed * 0.5 * delta;
            
            if (frontLeftWheel) {
                // Apply steering angle to front wheels
                frontLeftWheel.rotation.y = effectiveSteeringAngle;
                // Rotate wheel around its axis based on speed
                frontLeftWheel.children[0].rotation.x += wheelRotationSpeed;
            }
            
            if (frontRightWheel) {
                frontRightWheel.rotation.y = effectiveSteeringAngle;
                frontRightWheel.children[0].rotation.x += wheelRotationSpeed;
            }
            
            if (rearLeftWheel) {
                // Rear wheels don't steer but still rotate
                rearLeftWheel.children[0].rotation.x += wheelRotationSpeed;
            }
            
            if (rearRightWheel) {
                rearRightWheel.children[0].rotation.x += wheelRotationSpeed;
            }
            
            // Update camera position
            updateCamera();
            
            // Update score based on distance traveled
            score += Math.abs(movement);
            
            // Only update DOM once per 5 frames for better performance
            if (frameCount % 5 === 0) {
                document.getElementById('score').textContent = `Distance: ${Math.floor(score)}m`;
                document.getElementById('speed').textContent = `Speed: ${Math.floor(speed)} km/h`;
            }
        }
        
        function updateCamera() {
            // Position camera relative to car
            const idealOffset = cameraOffset.clone();
            idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation.y);
            
            camera.position.copy(car.position).add(idealOffset);
            camera.lookAt(car.position);
        }
        
        function checkCollisions() {
            // Check for obstacle collisions - only check obstacles near the car
            // Calculate car position once
            const carPos = new THREE.Vector3(car.position.x, 0, car.position.z);
            const carX = car.position.x;
            const carZ = car.position.z;
            
            // Reuse this variable for efficiency
            let dx, dz, distanceSquared;
            
            // Track if we've collided with any obstacle
            let hasCollided = false;
            
            // Optimize obstacle collision checks
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                // Skip collision checks for objects far from the car
                if (obstacle.collided) {
                    continue;
                }
                
                // Find the segment index for this obstacle
                let obstacleSegmentIndex = -1;
                for (let j = 0; j < track.length; j++) {
                    if (track[j].segment === obstacle.segment) {
                        obstacleSegmentIndex = j;
                        break;
                    }
                }
                
                // Skip if the obstacle's segment is too far from current segment
                if (obstacleSegmentIndex === -1 || Math.abs(obstacleSegmentIndex - currentSegment) > 5) {
                    continue; 
                }
                
                // Use fast squared distance check (avoid expensive sqrt)
                dx = carX - obstacle.mesh.position.x;
                dz = carZ - obstacle.mesh.position.z;
                distanceSquared = dx * dx + dz * dz;
                
                if (distanceSquared < 6.25) { // 2.5 * 2.5 = 6.25
                    if (activePowerUp !== 'shield') {
                        hasCollided = true;
                        break; // Exit early once we know we've collided
                    } else {
                        // Remove obstacle if we have a shield
                        scene.remove(obstacle.mesh);
                        obstacle.collided = true;
                    }
                }
            }
            
            if (hasCollided) {
                gameOver();
                return;
            }
            
            // Use a similar approach for power-ups with early return
            for (let i = 0; i < powerUps.length; i++) {
                const powerUp = powerUps[i];
                
                // Skip checks for objects that are far away or already collected
                if (powerUp.collected) {
                    continue;
                }
                
                // Find the segment index for this power-up
                let powerUpSegmentIndex = -1;
                for (let j = 0; j < track.length; j++) {
                    if (track[j].segment === powerUp.segment) {
                        powerUpSegmentIndex = j;
                        break;
                    }
                }
                
                // Skip if the power-up's segment is too far from current segment
                if (powerUpSegmentIndex === -1 || Math.abs(powerUpSegmentIndex - currentSegment) > 5) {
                    continue;
                }
                
                // Use fast squared distance check
                dx = carX - powerUp.mesh.position.x;
                dz = carZ - powerUp.mesh.position.z;
                distanceSquared = dx * dx + dz * dz;
                
                if (distanceSquared < 6.25) { // 2.5 * 2.5 = 6.25
                    collectPowerUp(powerUp);
                }
            }
            
            // First check transitions between segments for smoother handling
            let onTrack = checkSegmentTransitions(carPos);
            
            // If not at a transition, check individual segments
            if (!onTrack) {
                // Calculate search bounds to limit track segments we check
                const startSegment = Math.max(0, currentSegment - 2);
                const endSegment = Math.min(track.length, currentSegment + 3);
                
                // Check if car is on any track segment
                for (let i = startSegment; i < endSegment; i++) {
                    const segment = track[i];
                    
                    // For straight segments, calculate projection onto the line
                    const start = new THREE.Vector3(segment.start.x, 0, segment.start.z);
                    const end = new THREE.Vector3(segment.end.x, 0, segment.end.z);
                    const line = new THREE.Line3(start, end);
                    
                    const closestPoint = new THREE.Vector3();
                    line.closestPointToPoint(carPos, true, closestPoint);
                    
                    const distance = carPos.distanceTo(closestPoint);
                    
                    if (distance < trackWidth * 0.95) { // Very forgiving track width detection
                        onTrack = true;
                        
                        // If we're on a new segment, potentially generate more track
                        if (i > currentSegment) {
                            currentSegment = i;
                            
                            // Generate new track segments when we're approaching the end
                            // Now use the array index instead of the logical segment number
                            if (track.length - i < 5) {
                                // Add multiple segments at once to ensure we're always generating ahead
                                for (let j = 0; j < 5; j++) {  // Increased from 3 to 5 segments for better lookahead
                                    addTrackSegment();
                                }
                                
                                // Always ensure we have enough segments ahead
                                if (track.length - currentSegment < 10) {
                                    for (let j = 0; j < 3; j++) {
                                        addTrackSegment();
                                    }
                                }
                            }
                        }
                        
                        break;
                    }
                }
            }
            
            if (!onTrack && activePowerUp !== 'shield') {
                gameOver();
            }
        }
        
        function collectPowerUp(powerUp) {
            scene.remove(powerUp.mesh);
            powerUp.collected = true;
            
            activePowerUp = powerUp.type;
            
            if (powerUp.type === 'speed') {
                powerUpTimer = 5; // 5 seconds as per roadmap
                document.getElementById('powerup').textContent = 'Speed Boost Active!';
                document.getElementById('powerup').style.color = '#00ff00';
            } else if (powerUp.type === 'shield') {
                powerUpTimer = 10; // 10 seconds as per roadmap
                document.getElementById('powerup').textContent = 'Shield Active!';
                document.getElementById('powerup').style.color = '#0088ff';
                
                // Add visual shield effect - optimized with lower geometry detail
                const shieldGeometry = new THREE.SphereGeometry(3, 8, 8); // Reduced segments for better performance
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.3
                });
                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shield.name = 'shield';
                car.add(shield);
            } else if (powerUp.type === 'nitro') {
                // Nitro now activates automatically for 2 seconds as per roadmap
                powerUpTimer = 2; // 2 seconds
                document.getElementById('powerup').textContent = 'Nitro Active!';
                document.getElementById('powerup').style.color = '#ffcc00';
                
                // Add visual nitro effect
                const nitroEffect = createNitroEffect();
                nitroEffect.name = 'nitroEffect';
                car.add(nitroEffect);
                
                // No need for immediate speed boost here as it's handled in updateCar
            }
        }
        
        // Create visual effect for nitro
        function createNitroEffect() {
            const group = new THREE.Group();
            
            // Create flame-like cone
            const flameGeometry = new THREE.ConeGeometry(0.5, 1.5, 8);
            const flameMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.8
            });
            
            const flame = new THREE.Mesh(flameGeometry, flameMaterial);
            flame.position.z = -2.5; // Position behind the car
            flame.rotation.x = Math.PI; // Rotate to point backward
            
            group.add(flame);
            
            return group;
        }
        
        function updatePowerUps(delta) {
            // Update power-up timer and handle expiration
            if (activePowerUp && powerUpTimer > 0) {
                powerUpTimer -= delta;
                
                // Update nitro effect if active
                if (activePowerUp === 'nitro') {
                    const nitroEffect = car.getObjectByName('nitroEffect');
                    if (nitroEffect) {
                        // Animate the nitro effect
                        nitroEffect.children.forEach(child => {
                            if (child.isMesh) {
                                child.scale.x = 0.8 + Math.random() * 0.4;
                                child.scale.y = 0.8 + Math.random() * 0.4;
                            }
                        });
                    }
                }
                
                if (powerUpTimer <= 0) {
                    // Handle power-up expiration
                    if (activePowerUp === 'shield') {
                        // Remove shield visual - more efficient than using setTimeout
                        const shield = car.getObjectByName('shield');
                        if (shield) {
                            car.remove(shield);
                            // Help garbage collection
                            shield.geometry.dispose();
                            shield.material.dispose();
                        }
                    }
                    
                    // Remove nitro effect if it exists
                    const nitroEffect = car.getObjectByName('nitroEffect');
                    if (nitroEffect) {
                        car.remove(nitroEffect);
                        // Clean up resources
                        nitroEffect.children.forEach(child => {
                            if (child.isMesh) {
                                child.geometry.dispose();
                                child.material.dispose();
                            }
                        });
                    }
                    
                    // Always reset activePowerUp to null when timer expires
                    activePowerUp = null;
                    document.getElementById('powerup').textContent = '';
                }
            }

            // Update power-up visuals
            for (let i = 0; i < powerUps.length; i++) {
                const powerUp = powerUps[i];
                if (!powerUp.collected) {
                    // Rotate power-up
                    powerUp.mesh.rotation.y += powerUp.mesh.userData.rotationSpeed;
                    
                    // Float up and down
                    powerUp.mesh.userData.time += powerUp.mesh.userData.floatSpeed;
                    powerUp.mesh.position.y = powerUp.mesh.userData.baseY + 
                        Math.sin(powerUp.mesh.userData.time) * powerUp.mesh.userData.floatHeight;
                }
            }
        }
        
        function checkSegmentTransitions(carPos) {
            // This function checks if the car is at a segment transition
            // (between two segments) to avoid losing track detection between segments
            
            // Only check if we have at least 2 segments and not on the first segment
            if (track.length < 2 || currentSegment === 0) {
                return false;
            }
            
            // Get current and previous segments
            const currentSeg = track[currentSegment];
            const prevSeg = track[Math.max(0, currentSegment - 1)];
            
            // Check if we're near the transition between previous and current segment
            const transitionPoint = new THREE.Vector3(currentSeg.start.x, 0, currentSeg.start.z);
            const distToTransition = carPos.distanceTo(transitionPoint);
            
            // If we're near the transition point, check if we're on either segment
            if (distToTransition < trackWidth * 1.5) {
                // Check if on previous segment
                const prevStart = new THREE.Vector3(prevSeg.start.x, 0, prevSeg.start.z);
                const prevEnd = new THREE.Vector3(prevSeg.end.x, 0, prevSeg.end.z);
                const prevLine = new THREE.Line3(prevStart, prevEnd);
                
                const prevClosest = new THREE.Vector3();
                prevLine.closestPointToPoint(carPos, true, prevClosest);
                const prevDistance = carPos.distanceTo(prevClosest);
                
                if (prevDistance < trackWidth) {
                    return true;
                }
                
                // Check if on current segment
                const currStart = new THREE.Vector3(currentSeg.start.x, 0, currentSeg.start.z);
                const currEnd = new THREE.Vector3(currentSeg.end.x, 0, currentSeg.end.z);
                const currLine = new THREE.Line3(currStart, currEnd);
                
                const currClosest = new THREE.Vector3();
                currLine.closestPointToPoint(carPos, true, currClosest);
                const currDistance = carPos.distanceTo(currClosest);
                
                if (currDistance < trackWidth) {
                    return true;
                }
            }
            
            // Also check next segment if we're at the end of current segment
            if (currentSegment < track.length - 1) {
                const nextSeg = track[currentSegment + 1];
                const currentEnd = new THREE.Vector3(currentSeg.end.x, 0, currentSeg.end.z);
                const distToEnd = carPos.distanceTo(currentEnd);
                
                if (distToEnd < trackWidth * 1.5) {
                    // Check if on next segment
                    const nextStart = new THREE.Vector3(nextSeg.start.x, 0, nextSeg.start.z);
                    const nextEnd = new THREE.Vector3(nextSeg.end.x, 0, nextSeg.end.z);
                    const nextLine = new THREE.Line3(nextStart, nextEnd);
                    
                    const nextClosest = new THREE.Vector3();
                    nextLine.closestPointToPoint(carPos, true, nextClosest);
                    const nextDistance = carPos.distanceTo(nextClosest);
                    
                    if (nextDistance < trackWidth) {
                        // We're on the next segment, update currentSegment
                        currentSegment++;
                        
                        // Ensure we're generating more track if needed
                        if (track.length - currentSegment < 10) {
                            for (let j = 0; j < 3; j++) {
                                addTrackSegment();
                            }
                        }
                        
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function gameOver() {
            gameActive = false;
            
            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
            
            // Show game over screen
            document.getElementById('finalScore').textContent = `Distance: ${Math.floor(score)}m`;
            document.getElementById('highScore').textContent = `High Score: ${Math.floor(highScore)}m`;
            document.getElementById('gameOver').style.display = 'block';
            
            // Update UI visibility
            updateUIVisibility();
        }
        
        function resetGame() {
            // Reset game state variables first
            gameActive = false;
            score = 0;
            speed = 0;
            activePowerUp = null;
            powerUpTimer = 0;
            currentSegment = 0;
            
            // Clean up any active shield visual effects
            if (car) {
                const shield = car.getObjectByName('shield');
                if (shield) {
                    car.remove(shield);
                    shield.geometry.dispose();
                    shield.material.dispose();
                }
                
                const nitroEffect = car.getObjectByName('nitroEffect');
                if (nitroEffect) {
                    car.remove(nitroEffect);
                    nitroEffect.children.forEach(child => {
                        if (child.isMesh) {
                            child.geometry.dispose();
                            child.material.dispose();
                        }
                    });
                }
            }
            
            // Clear UI elements
            document.getElementById('powerup').textContent = '';
            
            // Remove all objects
            while(scene && scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            
            // Reset arrays
            track = [];
            obstacles = [];
            powerUps = [];
            groundTiles = []; // Also reset ground tiles
            environmentObjects = []; // Reset environment objects
            
            // Reset the sequential segment ID to ensure proper segment tracking
            window.sequentialSegmentId = 0;
            
            // Recreate scene without creating a new renderer
            init();
        }
        
        // Frame counting for throttling operations
        let frameCount = 0;
        let lastFrameTime = 0;
        let frameTimeHistory = [16, 16, 16, 16, 16]; // Initialize with reasonable default
        
        /**
         * Updates ground tiles around the car
         * Throttled to improve performance
         */
        function updateGroundTiles() {
            // Only check for new ground tiles every few frames to improve performance
            // This helps reduce the load on the requestAnimationFrame handler
            if (frameCount % 5 === 0) {
                checkAndCreateGroundTiles();
            }
        }
        
        /**
         * Cleans up distant objects to improve performance and memory usage
         * Staggers cleanup operations to avoid performance spikes
         */
        function cleanupDistantObjects() {
            // Only run cleanup every few frames, and less frequently when lagging
            const cleanupInterval = isLagging ? 10 : 5;
            if (frameCount % cleanupInterval !== 0) return;
            
            // Stagger cleanup operations based on frame count to avoid performance spikes
            const cleanupType = Math.floor(frameCount / cleanupInterval) % 3; // 0, 1, or 2
            
            if (cleanupType === 0) {
                // Clean up environment objects that are too far behind
                if (!environmentObjects.lastCleanupTime || Date.now() - environmentObjects.lastCleanupTime > (isLagging ? 10000 : 5000)) {
                    environmentObjects = environmentObjects.filter(object => {
                        if (object.segment === undefined || !object.mesh) return true;
                        
                        let segmentIndex = -1;
                        for (let i = 0; i < track.length; i++) {
                            if (track[i].segment === object.segment) {
                                segmentIndex = i;
                                break;
                            }
                        }
                        
                        if (segmentIndex === -1 || segmentIndex < currentSegment - 30) {
                            scene.remove(object.mesh);
                            return false;
                        }
                        return true;
                    });
                    environmentObjects.lastCleanupTime = Date.now();
                }
            } else if (cleanupType === 1) {
                // Clean up track segments
                if (!track.lastCleanupTime || Date.now() - track.lastCleanupTime > (isLagging ? 10000 : 5000)) {
                    const segmentsToKeep = Math.max(30, currentSegment + 20);
                    
                    if (track.length > segmentsToKeep) {
                        const currentSegmentId = track[currentSegment].segment;
                        
                        while (track.length > segmentsToKeep) {
                            const oldSegment = track.shift();
                            if (oldSegment.mesh) {
                                scene.remove(oldSegment.mesh);
                                if (oldSegment.material) objectPool.returnTrackMaterial(oldSegment.material);
                                if (oldSegment.mesh.geometry) oldSegment.mesh.geometry.dispose();
                            }
                        }
                        
                        for (let i = 0; i < track.length; i++) {
                            if (track[i].segment === currentSegmentId) {
                                currentSegment = i;
                                break;
                            }
                        }
                        
                        for (let i = 0; i < track.length; i++) {
                            track[i].arrayIndex = i;
                        }
                    }
                    track.lastCleanupTime = Date.now();
                }
            } else if (cleanupType === 2) {
                // Clean up ground tiles
                if (!groundTiles.lastCleanupTime || Date.now() - groundTiles.lastCleanupTime > (isLagging ? 10000 : 5000)) {
                    groundTiles = groundTiles.filter(tile => {
                        const dx = tile.x - carX;
                        const dz = tile.z - carZ;
                        const distanceSquared = dx * dx + dz * dz;
                        
                        if (distanceSquared > 700 * 700) {
                            scene.remove(tile.mesh);
                            if (tile.texture) objectPool.returnGroundTexture(tile.texture);
                            if (tile.mesh.material) {
                                if (Array.isArray(tile.mesh.material)) {
                                    tile.mesh.material.forEach(m => m.dispose());
                                } else {
                                    tile.mesh.material.dispose();
                                }
                            }
                            if (tile.mesh.geometry) tile.mesh.geometry.dispose();
                            return false;
                        }
                        return true;
                    });
                    groundTiles.lastCleanupTime = Date.now();
                }
            }
        }
        
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            // Calculate delta time
            const delta = Math.min(0.1, clock.getDelta()); // Cap delta to prevent large jumps
            
            // Update frame counter
            frameCount++;
            
            // Calculate actual frame time for adaptive performance
            const frameTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            
            // Update frame time history (moving average)
            frameTimeHistory.shift();
            frameTimeHistory.push(Math.min(100, frameTime)); // Cap at 100ms to avoid spikes
            
            // Calculate average frame time
            const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
            
            // Adaptive quality based on performance
            const isLagging = avgFrameTime > 30; // If average frame time is > 30ms we're not hitting 30fps
            
            // Only process game logic if game is active
            if (gameActive) {
                // Update car position and rotation
                updateCar(delta);
                
                // Throttle expensive operations when lagging
                const collisionInterval = isLagging ? 3 : 2;
                const environmentInterval = isLagging ? 5 : 3;
                
                // Run collision checks every few frames
                if (frameCount % collisionInterval === 0) {
                    checkCollisions();
                }
                
                // Update power-ups
                updatePowerUps(delta);
                
                // Check if we need to generate more track
                if (frameCount % environmentInterval === 0) {
                    // Check if we need to generate more track segments
                    const distanceToEnd = getDistanceToTrackEnd();
                    if (distanceToEnd < 100) {
                        addTrackSegment();
                    }
                    
                    // Update environment objects
                    updateEnvironment(delta);
                    
                    // Check for ground tiles that need to be created
                    updateGroundTiles();
                    
                    // Clean up distant objects
                    cleanupDistantObjects();
                }
                
                // Update orbit controls if active
                if (isOrbitCameraActive && orbitControls) {
                    orbitControls.update();
                    
                    // Use orbit camera for rendering
                    renderer.render(scene, orbitCamera);
                } else {
                    // Use regular camera for rendering
                    renderer.render(scene, camera);
                }
            } else {
                // Just render the scene with regular camera when game is not active
                renderer.render(scene, camera);
            }
        }
        
        function updateEnvironment(delta) {
            // Update environmental objects (lights, animations, etc.)
            // Only update visible objects (optimization)
            const visibleDistance = 100; // Only update objects within this distance
            
            // Cache car position for multiple checks
            const carX = car.position.x;
            const carZ = car.position.z;
            
            // Only update a subset of objects each frame to spread the load
            const objectsPerFrame = Math.min(environmentObjects.length, 10);
            const startIdx = frameCount % Math.max(1, environmentObjects.length - objectsPerFrame);
            const endIdx = Math.min(startIdx + objectsPerFrame, environmentObjects.length);
            
            for (let i = startIdx; i < endIdx; i++) {
                const object = environmentObjects[i];
                
                // Skip updates for distant objects
                if (object.segment !== undefined && Math.abs(object.segment - currentSegment) > 10) {
                    continue;
                }
                
                if (object.type === 'pulsingLight' && object.mesh) {
                    // Animate pulsing lights
                    object.mesh.userData.phase += delta * object.mesh.userData.speed;
                    object.mesh.intensity = object.mesh.userData.initialIntensity + 
                                           Math.sin(object.mesh.userData.phase) * 0.3;
                } else if (object.type === 'spotlight' && object.mesh && car) {
                    // Update spotlight to follow car
                    object.mesh.position.copy(car.position);
                    object.mesh.position.y += 10;
                    object.mesh.position.z -= 5;
                }
            }
            
            // Clean up environment objects that are too far behind
            // This operation is expensive, so only do it every 5 seconds (optimization)
            if (!environmentObjects.lastCleanupTime || Date.now() - environmentObjects.lastCleanupTime > 5000) {
                environmentObjects = environmentObjects.filter(object => {
                    // If this object is not segment-related or doesn't have a segment number, keep it
                    if (object.segment === undefined || !object.mesh) {
                        return true;
                    }
                    
                    // Find the index of the segment this object belongs to
                    let segmentIndex = -1;
                    for (let i = 0; i < track.length; i++) {
                        if (track[i].segment === object.segment) {
                            segmentIndex = i;
                            break;
                        }
                    }
                    
                    // If the segment doesn't exist anymore or is too far behind, remove the object
                    // Increased the distance to keep buildings visible longer
                    if (segmentIndex === -1 || segmentIndex < currentSegment - 30) {
                        scene.remove(object.mesh);
                        return false;
                    }
                    return true;
                });
                environmentObjects.lastCleanupTime = Date.now();
            }
            
            // Check if we need to clean up track segments
            // This operation is expensive, so only do it every 5 seconds
            if (!track.lastCleanupTime || Date.now() - track.lastCleanupTime > 5000) {
                // Clean up obsolete track segments, but leave a generous buffer
                // Keep at least 20 segments behind the player to allow for backtracking
                // and 30 segments in total to ensure plenty of track exists
                const segmentsToKeep = Math.max(30, currentSegment + 20);
                
                if (track.length > segmentsToKeep) {
                    // Store current segment's logical ID before cleanup
                    const currentSegmentId = track[currentSegment].segment;
                    
                    // Keep removing segments from the beginning as long as we have enough buffer segments
                    while (track.length > segmentsToKeep) {
                        const oldSegment = track.shift();
                        if (oldSegment.mesh) {
                            scene.remove(oldSegment.mesh);
                            
                            // Return track material to object pool
                            if (oldSegment.material) {
                                objectPool.returnTrackMaterial(oldSegment.material);
                            }
                            
                            // Dispose of geometry
                            if (oldSegment.mesh.geometry) {
                                oldSegment.mesh.geometry.dispose();
                            }
                        }
                    }
                    
                    // Find the new array index of the segment we were on
                    for (let i = 0; i < track.length; i++) {
                        if (track[i].segment === currentSegmentId) {
                            currentSegment = i;
                            break;
                        }
                    }
                    
                    // Update the arrayIndex property of all remaining segments
                    for (let i = 0; i < track.length; i++) {
                        track[i].arrayIndex = i;
                    }
                }
                track.lastCleanupTime = Date.now();
            }
            
            // Clean up ground tiles that are too far behind
            // This operation is expensive, so only do it every 5 seconds
            if (!groundTiles.lastCleanupTime || Date.now() - groundTiles.lastCleanupTime > 5000) {
                groundTiles = groundTiles.filter(tile => {
                    // Calculate distance to car (use squared distance for efficiency)
                    const dx = tile.x - carX;
                    const dz = tile.z - carZ;
                    const distanceSquared = dx * dx + dz * dz;
                    
                    // Remove tiles that are too far away
                    if (distanceSquared > 700 * 700) {
                        scene.remove(tile.mesh);
                        
                        // Return texture to object pool for reuse
                        if (tile.texture) {
                            objectPool.returnGroundTexture(tile.texture);
                        }
                        
                        // Dispose of materials and geometry
                        if (tile.mesh.material) {
                            if (Array.isArray(tile.mesh.material)) {
                                tile.mesh.material.forEach(m => m.dispose());
                            } else {
                                tile.mesh.material.dispose();
                            }
                        }
                        
                        if (tile.mesh.geometry) {
                            tile.mesh.geometry.dispose();
                        }
                        
                        return false;
                    }
                    return true;
                });
                groundTiles.lastCleanupTime = Date.now();
            }
            
            // Animate tech trees
            for (let i = 0; i < environmentObjects.length; i++) {
                const object = environmentObjects[i];
                
                if (object.type === 'tree' && object.mesh) {
                    // Update animation time
                    if (object.mesh.userData && object.mesh.userData.type === 'techTree') {
                        object.mesh.userData.animationTime += delta;
                        
                        // Animate based on tree style
                        object.mesh.traverse(child => {
                            if (child.userData) {
                                // Animate floating orbs
                                if (child.userData.floatHeight !== undefined) {
                                    child.userData.time += delta * child.userData.floatSpeed;
                                    child.position.y = child.userData.baseY + 
                                        Math.sin(child.userData.time) * child.userData.floatHeight;
                                }
                                
                                // Animate rotating panels
                                if (child.userData.rotationSpeed !== undefined) {
                                    child.rotation.y += child.userData.rotationSpeed;
                                    
                                    if (child.userData.baseRadius !== undefined) {
                                        child.userData.time += delta * child.userData.floatSpeed;
                                        const angle = child.userData.baseAngle + object.mesh.userData.animationTime * 0.2;
                                        child.position.x = Math.sin(angle) * child.userData.baseRadius;
                                        child.position.z = Math.cos(angle) * child.userData.baseRadius;
                                        child.position.y = child.userData.baseY + 
                                            Math.sin(child.userData.time) * child.userData.floatHeight;
                                        
                                        // Make panel face center
                                        child.lookAt(new THREE.Vector3(0, child.position.y, 0));
                                    }
                                }
                                
                                // Animate pulsing tips
                                if (child.userData.pulseSpeed !== undefined) {
                                    child.userData.time += delta * child.userData.pulseSpeed;
                                    const pulse = 0.7 + Math.sin(child.userData.time) * 0.3;
                                    child.scale.set(pulse, pulse, pulse);
                                }
                            }
                        });
                    }
                }
                
                // Animate building windows
                if (object.type === 'building' && object.mesh) {
                    object.mesh.traverse(child => {
                        if (child.userData && child.userData.isWindow) {
                            // Update time
                            child.userData.time += delta * child.userData.flickerSpeed;
                            
                            // Flickering effect for windows
                            if (child.material && child.material.emissiveIntensity) {
                                if (Math.random() > 0.97) { // Occasional flicker
                                    child.material.emissiveIntensity = child.userData.originalIntensity * 
                                        (Math.random() > 0.5 ? 1.5 : 0.5);
                                } else {
                                    // Subtle pulsing
                                    child.material.emissiveIntensity = child.userData.originalIntensity * 
                                        (0.9 + Math.sin(child.userData.time) * 0.1);
                                }
                            }
                        }
                    });
                }
            }
            
            // Animate obstacles
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                if (obstacle.mesh && obstacle.mesh.userData) {
                    // Update animation time
                    if (!obstacle.mesh.userData.animationTime) {
                        obstacle.mesh.userData.animationTime = 0;
                    }
                    obstacle.mesh.userData.animationTime += delta;
                    
                    // Animate based on obstacle type
                    if (obstacle.mesh.userData.type === 'holographicBarrier') {
                        // Rotate and pulse the holographic panels
                        obstacle.mesh.traverse(child => {
                            if (child.userData && child.userData.rotationSpeed) {
                                // Rotate the panel
                                child.rotation.y += child.userData.rotationSpeed * delta;
                                
                                // Pulse the opacity
                                if (child.material && child.material.opacity) {
                                    child.userData.time += delta * child.userData.pulseSpeed;
                                    child.material.opacity = 0.4 + Math.sin(child.userData.time) * 0.3;
                                }
                            }
                        });
                    } else if (obstacle.mesh.userData.type === 'damagedVehicle') {
                        // Flicker the lights on damaged vehicles
                        obstacle.mesh.traverse(child => {
                            if (child.userData && child.userData.flickerSpeed) {
                                child.userData.time += delta * child.userData.flickerSpeed;
                                
                                // Random flickering effect
                                if (child.material && child.material.emissiveIntensity) {
                                    if (Math.sin(child.userData.time * 10) > 0.7) {
                                        child.material.emissiveIntensity = child.userData.originalIntensity;
                                    } else if (Math.random() > 0.7) {
                                        child.material.emissiveIntensity = 0;
                                    } else {
                                        child.material.emissiveIntensity = child.userData.originalIntensity * 
                                            (0.5 + Math.random() * 0.5);
                                    }
                                }
                            }
                        });
                    }
                }
            }
            
            // Animate street lights
            for (let i = 0; i < environmentObjects.length; i++) {
                const object = environmentObjects[i];
                
                if (object.type === 'streetLight' && object.mesh) {
                    object.mesh.traverse(child => {
                        if (child.isPointLight && child.userData && child.userData.flickerSpeed) {
                            // Update time
                            child.userData.time += delta * child.userData.flickerSpeed;
                            
                            // Subtle flickering effect for street lights
                            const flicker = 0.9 + Math.sin(child.userData.time * 5) * 0.1;
                            
                            // Occasional stronger flicker
                            if (Math.random() > 0.99) {
                                child.intensity = child.userData.originalIntensity * (Math.random() * 0.5 + 0.5);
                            } else {
                                child.intensity = child.userData.originalIntensity * flicker;
                            }
                        }
                    });
                }
            }
            
            // Animate billboards
            for (let i = 0; i < environmentObjects.length; i++) {
                const object = environmentObjects[i];
                
                if (object.type === 'billboard' && object.mesh) {
                    // Animate neon text elements
                    object.mesh.traverse(child => {
                        if (child.userData && child.userData.isNeonSign) {
                            child.userData.time += delta * child.userData.flickerSpeed;
                            
                            // Flickering effect
                            if (Math.random() > 0.98) { // Occasional flicker
                                child.material.emissiveIntensity = child.userData.originalIntensity * 
                                    (Math.random() > 0.5 ? 1.5 : 0.3);
                            } else {
                                // Subtle pulsing
                                child.material.emissiveIntensity = child.userData.originalIntensity * 
                                    (0.8 + Math.sin(child.userData.time) * 0.2);
                            }
                        }
                    });
                }
                
                // Animate holographic ads
                if (object.type === 'hologram' && object.mesh) {
                    object.mesh.traverse(child => {
                        if (child.userData && child.userData.isHologram) {
                            child.userData.time += delta * child.userData.pulseSpeed;
                            
                            // Pulse opacity
                            if (child.material && child.material.opacity) {
                                child.material.opacity = child.userData.originalOpacity * 
                                    (0.7 + Math.sin(child.userData.time) * 0.3);
                            }
                            
                            // Rotate the hologram
                            if (child.userData.rotationSpeed) {
                                child.rotation.y += delta * child.userData.rotationSpeed;
                            }
                        }
                    });
                }
            }
        }
        
        // Add the missing addEnvironmentObject function
        function addEnvironmentObject(segment, type) {
            // Determine object based on type parameter
            let geometry, material, mesh;
            let scale = 1;
            let height = 0;
            let segmentOffset = 0;
            
            // Calculate track direction for positioning
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Randomize position along track
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Create different objects based on type
            if (type === 'building') {
                // Create a cyberpunk-style building with windows
                const buildingWidth = 6 + Math.random() * 6;
                const buildingHeight = 10 + Math.random() * 20;
                const buildingDepth = 6 + Math.random() * 6;
                
                // Create the main building structure
                geometry = new THREE.BoxGeometry(buildingWidth, buildingHeight, buildingDepth);
                
                // Use one of the neon colors for emissive trim
                const neonColors = themeSettings[theme].neonColors;
                const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                
                // Create a procedural texture for the building with windows
                const buildingTexture = createBuildingTexture(buildingWidth, buildingHeight, buildingDepth, neonColor);
                
                material = new THREE.MeshPhongMaterial({
                    color: 0x111111,
                    emissive: neonColor,
                    emissiveIntensity: 0.2,
                    map: buildingTexture,
                    emissiveMap: buildingTexture
                });
                
                mesh = new THREE.Mesh(geometry, material);
                
                // Add neon trim to the building edges
                addBuildingNeonTrim(mesh, buildingWidth, buildingHeight, buildingDepth, neonColor);
                
                height = buildingHeight / 2;
                scale = 1;
                
                // Place buildings further away from track
                segmentOffset = (10 + Math.random() * 15) * (Math.random() > 0.5 ? 1 : -1);
            } else if (type === 'tree') {
                // Create an enhanced cyberpunk-style "tech tree"
                mesh = new THREE.Group();
                
                // Choose a random tree style
                const treeStyle = Math.floor(Math.random() * 3);
                
                // Use one of the neon colors
                const neonColors = themeSettings[theme].neonColors;
                const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                
                if (treeStyle === 0) {
                    // Style 1: Tech pillar with multiple glowing orbs
                    const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 5, 6);
                    const trunkMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x222222,
                        emissive: neonColor,
                        emissiveIntensity: 0.2
                    });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    mesh.add(trunk);
                    
                    // Add multiple glowing orbs at different heights
                    const orbCount = 2 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < orbCount; i++) {
                        const orbSize = 0.5 + Math.random() * 1.0;
                        const orbGeometry = new THREE.SphereGeometry(orbSize, 8, 8);
                        const orbMaterial = new THREE.MeshPhongMaterial({
                            color: 0x222222,
                            emissive: neonColor,
                            emissiveIntensity: 0.8
                        });
                        
                        const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                        const height = (i + 1) * (5 / (orbCount + 1));
                        const offset = (Math.random() - 0.5) * 1.5;
                        orb.position.set(offset, height, offset);
                        
                        // Add animation data to the orb
                        orb.userData = {
                            floatSpeed: 0.5 + Math.random() * 1.0,
                            floatHeight: 0.2 + Math.random() * 0.3,
                            time: Math.random() * Math.PI * 2,
                            baseY: height
                        };
                        
                        mesh.add(orb);
                    }
                    
                } else if (treeStyle === 1) {
                    // Style 2: Holographic tree with floating panels
                    const baseGeometry = new THREE.CylinderGeometry(0.4, 0.6, 1, 6);
                    const baseMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x333333,
                        emissive: neonColor,
                        emissiveIntensity: 0.3
                    });
                    const base = new THREE.Mesh(baseGeometry, baseMaterial);
                    base.position.y = 0.5;
                    mesh.add(base);
                    
                    // Add floating panels
                    const panelCount = 3 + Math.floor(Math.random() * 4);
                    for (let i = 0; i < panelCount; i++) {
                        const panelWidth = 0.5 + Math.random() * 1.0;
                        const panelHeight = 1.0 + Math.random() * 2.0;
                        const panelGeometry = new THREE.PlaneGeometry(panelWidth, panelHeight);
                        const panelMaterial = new THREE.MeshPhongMaterial({
                            color: 0x111111,
                            emissive: neonColor,
                            emissiveIntensity: 0.6,
                            transparent: true,
                            opacity: 0.7,
                            side: THREE.DoubleSide
                        });
                        
                        const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                        const angle = (i / panelCount) * Math.PI * 2;
                        const radius = 0.8 + Math.random() * 0.5;
                        const height = 1.0 + Math.random() * 3.0;
                        
                        panel.position.set(
                            Math.sin(angle) * radius,
                            height,
                            Math.cos(angle) * radius
                        );
                        
                        // Rotate panel to face center
                        panel.lookAt(new THREE.Vector3(0, height, 0));
                        
                        // Add animation data
                        panel.userData = {
                            rotationSpeed: (Math.random() - 0.5) * 0.02,
                            floatSpeed: 0.3 + Math.random() * 0.7,
                            floatHeight: 0.1 + Math.random() * 0.2,
                            time: Math.random() * Math.PI * 2,
                            baseY: height,
                            baseAngle: angle,
                            baseRadius: radius
                        };
                        
                        mesh.add(panel);
                    }
                    
                } else {
                    // Style 3: Neon wire frame tree
                    const trunkHeight = 3 + Math.random() * 3;
                    
                    // Create trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, trunkHeight, 5);
                    const trunkMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0x333333,
                        emissive: neonColor,
                        emissiveIntensity: 0.3,
                        wireframe: true
                    });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = trunkHeight / 2;
                    mesh.add(trunk);
                    
                    // Create branches
                    const branchCount = 3 + Math.floor(Math.random() * 3);
                    for (let i = 0; i < branchCount; i++) {
                        const branchHeight = trunkHeight * (0.3 + (i / branchCount) * 0.6);
                        const branchLength = 1 + Math.random() * 2;
                        const branchGeometry = new THREE.CylinderGeometry(0.05, 0.1, branchLength, 5);
                        const branchMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0x333333,
                            emissive: neonColor,
                            emissiveIntensity: 0.5,
                            wireframe: true
                        });
                        
                        const branch = new THREE.Mesh(branchGeometry, branchMaterial);
                        
                        // Position and rotate branch
                        const angle = (i / branchCount) * Math.PI * 2;
                        branch.position.set(
                            0,
                            branchHeight,
                            0
                        );
                        
                        // Rotate branch outward
                        branch.rotation.z = Math.PI / 2;
                        branch.rotation.y = angle;
                        
                        // Position branch so one end connects to trunk
                        branch.position.x += Math.sin(angle) * (branchLength / 2);
                        branch.position.z += Math.cos(angle) * (branchLength / 2);
                        
                        mesh.add(branch);
                        
                        // Add a glowing tip to the branch
                        const tipGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                        const tipMaterial = new THREE.MeshPhongMaterial({
                            color: 0x222222,
                            emissive: neonColor,
                            emissiveIntensity: 1.0
                        });
                        
                        const tip = new THREE.Mesh(tipGeometry, tipMaterial);
                        tip.position.set(
                            Math.sin(angle) * branchLength,
                            branchHeight,
                            Math.cos(angle) * branchLength
                        );
                        
                        // Add animation data
                        tip.userData = {
                            pulseSpeed: 0.5 + Math.random() * 1.0,
                            time: Math.random() * Math.PI * 2
                        };
                        
                        mesh.add(tip);
                    }
                }
                
                // Add animation data to the entire tree
                mesh.userData = {
                    type: 'techTree',
                    style: treeStyle,
                    animationTime: 0
                };
                
                height = 0;
                scale = 0.8 + Math.random() * 0.4;
                
                // Place trees not too far from track
                segmentOffset = (6 + Math.random() * 10) * (Math.random() > 0.5 ? 1 : -1);
            } else if (type === 'debris') {
                // Create some cyberpunk debris/junk
                if (Math.random() > 0.5) {
                    // Create a pile of boxes
                    mesh = new THREE.Group();
                    
                    for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                        const boxSize = 0.5 + Math.random() * 1.5;
                        const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
                        
                        const boxMaterial = new THREE.MeshPhongMaterial({
                            color: 0x333333
                        });
                        
                        const box = new THREE.Mesh(boxGeometry, boxMaterial);
                        box.position.set(
                            (Math.random() - 0.5) * 2,
                            boxSize / 2 + Math.random() * 0.5,
                            (Math.random() - 0.5) * 2
                        );
                        
                        box.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        );
                        
                        mesh.add(box);
                    }
                } else {
                    // Create a damaged vehicle or tech item
                    geometry = new THREE.BoxGeometry(2 + Math.random(), 1 + Math.random(), 3 + Math.random());
                    material = new THREE.MeshPhongMaterial({ 
                        color: 0x555555,
                        emissive: 0xff0000,
                        emissiveIntensity: Math.random() * 0.3
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    height = geometry.parameters.height / 2;
                }
                
                scale = 0.7 + Math.random() * 0.6;
                
                // Place debris closer to track
                segmentOffset = (3 + Math.random() * 7) * (Math.random() > 0.5 ? 1 : -1);
            }
            
            if (mesh) {
                // Calculate final position
                const posX = segment.start.x + dirX * alongTrack + perpX * segmentOffset;
                const posZ = segment.start.z + dirZ * alongTrack + perpZ * segmentOffset;
                
                mesh.position.set(posX, height, posZ);
                mesh.scale.set(scale, scale, scale);
                
                // Add subtle random rotation
                mesh.rotation.y = Math.random() * Math.PI * 2;
                
                // Enable shadows
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Apply material settings to all child meshes in case of groups
                mesh.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(mesh);
                
                // Add to environment objects array with segment reference
                environmentObjects.push({
                    mesh: mesh,
                    type: type,
                    segment: track.length - 1  // Current segment being built
                });
            }
        }
        
        // Add the missing onWindowResize function
        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // Update orbit camera aspect ratio
            if (orbitCamera) {
                orbitCamera.aspect = window.innerWidth / window.innerHeight;
                orbitCamera.updateProjectionMatrix();
            }
            
            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize the game
        init();
        
        // Start animation with timestamp
        requestAnimationFrame(animate);
        
        // Create track material with cyberpunk style
        function createTrackMaterial() {
            // Create track texture with lane markings - cyberpunk style
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            // Fill with road color (dark for cyberpunk but not too dark)
            context.fillStyle = '#111111';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add asphalt texture
            const size = 16; // Increase size for better performance
            const noise = 0.1;
            context.fillStyle = '#0a0a0a';
            
            // Use a more efficient approach to drawing noise
            for (let x = 0; x < canvas.width; x += size * 2) {
                for (let y = 0; y < canvas.height; y += size * 2) {
                    if (Math.random() < 0.3) {
                        context.globalAlpha = 0.05 + Math.random() * noise;
                        context.fillRect(x, y, size, size);
                    }
                }
            }
            
            context.globalAlpha = 1.0;
            
            // Add cyberpunk grid pattern
            context.strokeStyle = '#00ffff';
            context.lineWidth = 1;
            context.setLineDash([1, 8]);
            
            // Horizontal grid lines - draw fewer lines for better performance
            for (let y = 0; y < canvas.height; y += 64) { // Increased spacing
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(canvas.width, y);
                context.stroke();
            }
            
            // Draw road edges - neon style
            context.strokeStyle = '#ff00ff'; // Magenta neon
            context.lineWidth = 8;
            context.setLineDash([]);
            
            // Left edge
            context.beginPath();
            context.moveTo(canvas.width * 0.1, 0);
            context.lineTo(canvas.width * 0.1, canvas.height);
            context.stroke();
            
            // Right edge
            context.beginPath();
            context.moveTo(canvas.width * 0.9, 0);
            context.lineTo(canvas.width * 0.9, canvas.height);
            context.stroke();
            
            // Draw center dashed line - neon cyan
            context.strokeStyle = '#00ffff';
            context.lineWidth = 6;
            context.setLineDash([20, 20]);
            context.beginPath();
            context.moveTo(canvas.width / 2, 0);
            context.lineTo(canvas.width / 2, canvas.height);
            context.stroke();
            
            // Create texture
            const texture = new THREE.CanvasTexture(canvas);
            texture.repeat.set(1, 5);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            // Create material with brighter emissive for neon glow effect
            // And with depth write enabled to avoid z-fighting
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.DoubleSide,
                emissive: 0x330066,
                emissiveIntensity: 0.5, // Increased emissive intensity
                depthWrite: true, // Enable depth write
                polygonOffset: true, // Enable polygon offset
                polygonOffsetFactor: -1, // Apply a small offset to fix z-fighting
                polygonOffsetUnits: -1
            });
            
            return material;
        }
        
        // Set up UI button event listeners
        document.getElementById('startGame').addEventListener('click', function() {
            document.getElementById('menu').style.display = 'none';
            
            // Reset power-up state when starting a new game
            activePowerUp = null;
            powerUpTimer = 0;
            document.getElementById('powerup').textContent = '';
            
            // Remove any existing shield or nitro effects
            if (car) {
                const shield = car.getObjectByName('shield');
                if (shield) {
                    car.remove(shield);
                    shield.geometry.dispose();
                    shield.material.dispose();
                }
                
                const nitroEffect = car.getObjectByName('nitroEffect');
                if (nitroEffect) {
                    car.remove(nitroEffect);
                    nitroEffect.children.forEach(child => {
                        if (child.isMesh) {
                            child.geometry.dispose();
                            child.material.dispose();
                        }
                    });
                }
            }
            
            gameActive = true;
            updateUIVisibility();
        });
        
        document.getElementById('playAgain').addEventListener('click', function() {
            document.getElementById('gameOver').style.display = 'none';
            
            // Ensure power-up state is reset
            activePowerUp = null;
            powerUpTimer = 0;
            document.getElementById('powerup').textContent = '';
            
            resetGame();
            gameActive = true;
            updateUIVisibility();
        });
        
        document.getElementById('mainMenu').addEventListener('click', function() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('menu').style.display = 'block';
            
            // Ensure power-up state is reset
            activePowerUp = null;
            powerUpTimer = 0;
            document.getElementById('powerup').textContent = '';
            
            resetGame();
            updateUIVisibility();
        });
        
        // Tutorial button event listener
        document.getElementById('tutorialBtn').addEventListener('click', function() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('tutorialPage').style.display = 'block';
        });
        
        // Tutorial back button event listener
        document.getElementById('tutorialBackBtn').addEventListener('click', function() {
            document.getElementById('tutorialPage').style.display = 'none';
            document.getElementById('menu').style.display = 'block';
        });
        
        // Credits button event listener
        document.getElementById('creditsBtn').addEventListener('click', function() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('creditsPage').style.display = 'block';
        });
        
        // Credits back button event listener
        document.getElementById('creditsBackBtn').addEventListener('click', function() {
            document.getElementById('creditsPage').style.display = 'none';
            document.getElementById('menu').style.display = 'block';
        });
        
        // Leaderboard button event listener
        document.getElementById('leaderboardBtn').addEventListener('click', function() {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('leaderboardPage').style.display = 'block';
            
            // Update personal high score display
            document.getElementById('personalHighScore').textContent = `${Math.floor(highScore)}m`;
        });
        
        // Leaderboard back button event listener
        document.getElementById('leaderboardBackBtn').addEventListener('click', function() {
            document.getElementById('leaderboardPage').style.display = 'none';
            document.getElementById('menu').style.display = 'block';
        });
        
        document.getElementById('shareScore').addEventListener('click', function() {
            const scoreText = `I reached ${Math.floor(score)}m in Endless Drive!`;
            
            // Try to use the Web Share API if available
            if (navigator.share) {
                navigator.share({
                    title: 'Endless Drive Score',
                    text: scoreText,
                }).catch(error => {
                    console.log('Error sharing:', error);
                    // Fallback to copying to clipboard
                    copyToClipboard(scoreText);
                });
            } else {
                // Fallback to copying to clipboard
                copyToClipboard(scoreText);
            }
        });
        
        // Helper function for copying to clipboard
        function copyToClipboard(text) {
            const tempInput = document.createElement('input');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            
            alert('Score copied to clipboard: ' + text);
        }
        
        // Function to detect if device has touch capability
        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0));
        }
        
        // Set up mobile controls with joystick
        function setupMobileControls() {
            const mobileControls = document.getElementById('mobileControls');
            
            // Only show mobile controls on touch devices
            isMobileDevice = isTouchDevice();
            if (isMobileDevice) {
                mobileControls.style.display = 'block';
                
                // Initialize joystick
                const joystickOptions = {
                    zone: document.getElementById('joystickZone'),
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    size: window.innerHeight > window.innerWidth ? 120 : 150, // Larger in landscape mode
                    color: 'rgba(255, 0, 255, 0.5)',
                    lockX: false,
                    lockY: false // Allow movement in all directions
                };
                
                let joystick = nipplejs.create(joystickOptions);
                
                // Handle orientation changes to update joystick size
                window.addEventListener('orientationchange', function() {
                    // Destroy and recreate joystick with new size after orientation change
                    setTimeout(function() {
                        joystick.destroy();
                        const newSize = window.innerHeight > window.innerWidth ? 120 : 150;
                        const newJoystickOptions = {
                            zone: document.getElementById('joystickZone'),
                            mode: 'static',
                            position: { left: '50%', top: '50%' },
                            size: newSize,
                            color: 'rgba(255, 0, 255, 0.5)',
                            lockX: false,
                            lockY: false
                        };
                        // Update the joystick variable with the new instance
                        joystick = nipplejs.create(newJoystickOptions);
                        
                        // Reattach event handlers
                        joystick.on('move', function(evt, data) {
                            joystickInput = data.vector.x;
                            
                            // Apply a small deadzone to prevent tiny movements
                            if (Math.abs(joystickInput) < 0.1) {
                                joystickInput = 0;
                            }
                            
                            keys['arrowleft'] = false;
                            keys['arrowright'] = false;
                        });
                        
                        joystick.on('end', function() {
                            joystickInput = 0;
                        });
                    }, 300); // Small delay to ensure DOM has updated
                });
                
                // Joystick event handlers
                joystick.on('move', function(evt, data) {
                    // Calculate steering input from joystick position
                    // Make sure we're using the correct vector component for steering
                    // data.vector.x is between -1 and 1
                    joystickInput = data.vector.x;
                    
                    // Apply a small deadzone to prevent tiny movements
                    if (Math.abs(joystickInput) < 0.1) {
                        joystickInput = 0;
                    }
                    
                    // Clear keyboard inputs to avoid conflicts
                    keys['arrowleft'] = false;
                    keys['arrowright'] = false;
                });
                
                joystick.on('end', function() {
                    // Reset joystick input when released
                    joystickInput = 0;
                });
                
                // Set up touch event listeners for pedal controls
                const accelerateBtn = document.getElementById('accelerateBtn');
                const brakeBtn = document.getElementById('brakeBtn');
                
                // Acceleration button
                accelerateBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keys['arrowup'] = true;
                });
                accelerateBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keys['arrowup'] = false;
                });
                
                // Brake button
                brakeBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keys['arrowdown'] = true;
                });
                brakeBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keys['arrowdown'] = false;
                });
                
                // Prevent default touch actions on the canvas to avoid scrolling
                renderer.domElement.addEventListener('touchmove', function(e) {
                    if (gameActive) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Prevent pinch zoom on mobile
                document.addEventListener('touchmove', function(e) {
                    if (e.touches.length > 1 && gameActive) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Prevent double-tap zoom
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function(e) {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, { passive: false });
            }
        }
        
        // Handle preloader
        window.addEventListener('load', function() {
            // Hide preloader after everything is loaded
            setTimeout(function() {
                const preloader = document.getElementById('preloader');
                preloader.style.opacity = '0';
                setTimeout(function() {
                    preloader.style.display = 'none';
                }, 500);
            }, 500);
        });
        
        // Handle keydown events
        function handleKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            
            // Toggle orbit camera with 'o' key (only for desktop)
            if (e.key.toLowerCase() === 'o' && !isMobileDevice) {
                isOrbitCameraActive = !isOrbitCameraActive;
                
                if (orbitControls) {
                    orbitControls.enabled = isOrbitCameraActive;
                    
                    if (isOrbitCameraActive) {
                        // Update orbit camera position to follow the car
                        orbitCamera.position.copy(car.position).add(new THREE.Vector3(15, 15, 15));
                        orbitControls.target.copy(car.position);
                    }
                }
                
                console.log("Orbit camera " + (isOrbitCameraActive ? "enabled" : "disabled"));
            }
        }
        
        // Handle keyup events
        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }
        
        // Function to create a procedural texture for buildings with windows
        function createBuildingTexture(width, height, depth, neonColor) {
            // Create a canvas for the texture
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Fill with building base color (dark)
            ctx.fillStyle = '#111111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Convert neon color to CSS format
            const neonColorHex = '#' + neonColor.toString(16).padStart(6, '0');
            
            // Add grid pattern for cyberpunk feel
            ctx.strokeStyle = '#222222';
            ctx.lineWidth = 2;
            
            // Horizontal grid lines
            const gridSize = 32;
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Vertical grid lines
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Add windows with enhanced lighting
            const windowSize = 16;
            const windowSpacing = 32;
            const windowRows = Math.floor(canvas.height / windowSpacing);
            const windowCols = Math.floor(canvas.width / windowSpacing);
            
            for (let row = 0; row < windowRows; row++) {
                for (let col = 0; col < windowCols; col++) {
                    // Randomly decide if this window is lit
                    if (Math.random() < 0.8) { // Increased probability for more lit windows
                        // Window position
                        const x = col * windowSpacing + (windowSpacing - windowSize) / 2;
                        const y = row * windowSpacing + (windowSpacing - windowSize) / 2;
                        
                        // Random window color (either neon color or white/blue for interior light)
                        const windowColor = Math.random() < 0.3 ? neonColorHex : (Math.random() < 0.5 ? '#88ccff' : '#ffffff');
                        
                        // Random brightness - increased for better visibility
                        const alpha = 0.6 + Math.random() * 0.4; // Increased minimum brightness
                        ctx.globalAlpha = alpha;
                        
                        // Draw window with slight random size variation for more organic look
                        const randomSize = windowSize * (0.9 + Math.random() * 0.2);
                        ctx.fillStyle = windowColor;
                        ctx.fillRect(x, y, randomSize, randomSize);
                        
                        // Add a stronger glow effect
                        const glow = ctx.createRadialGradient(
                            x + randomSize/2, y + randomSize/2, 0,
                            x + randomSize/2, y + randomSize/2, randomSize * 1.5
                        );
                        glow.addColorStop(0, windowColor);
                        glow.addColorStop(1, 'rgba(0,0,0,0)');
                        
                        ctx.globalAlpha = 0.5; // Increased glow opacity
                        ctx.fillStyle = glow;
                        ctx.fillRect(x - randomSize, y - randomSize, randomSize*3, randomSize*3);
                    }
                }
            }
            
            // Reset alpha
            ctx.globalAlpha = 1.0;
            
            // Create texture from canvas
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            // Scale texture based on building dimensions
            texture.repeat.set(width/5, height/5);
            
            return texture;
        }
        
        // Function to add neon trim to building edges
        function addBuildingNeonTrim(buildingMesh, width, height, depth, neonColor) {
            // Create a group to hold the building and its trim
            const buildingGroup = new THREE.Group();
            buildingGroup.add(buildingMesh);
            
            // Create neon trim for the top edges
            const edgeGeometry = new THREE.BoxGeometry(width + 0.1, 0.2, depth + 0.1);
            const edgeMaterial = new THREE.MeshPhongMaterial({
                color: 0x111111,
                emissive: neonColor,
                emissiveIntensity: 1.5 // Increased intensity
            });
            
            // Top edge
            const topEdge = new THREE.Mesh(edgeGeometry, edgeMaterial);
            topEdge.position.y = height / 2 + 0.1;
            buildingGroup.add(topEdge);
            
            // Add vertical corner trims
            const cornerGeometry = new THREE.BoxGeometry(0.2, height, 0.2);
            
            // Create 4 corner trims
            for (let i = 0; i < 4; i++) {
                const xPos = (i % 2 === 0 ? -1 : 1) * (width / 2);
                const zPos = (i < 2 ? -1 : 1) * (depth / 2);
                
                const corner = new THREE.Mesh(cornerGeometry, edgeMaterial);
                corner.position.set(xPos, 0, zPos);
                buildingGroup.add(corner);
            }
            
            // Add actual 3D windows that protrude slightly from the building
            // Only add to larger buildings to avoid overwhelming small ones
            if (width > 8 && height > 15) {
                const windowCount = Math.floor(Math.random() * 5) + 3; // 3-7 windows
                
                for (let i = 0; i < windowCount; i++) {
                    // Create a window that protrudes from the building
                    const windowWidth = 1.2 + Math.random() * 0.8;
                    const windowHeight = 1.2 + Math.random() * 0.8;
                    const windowGeometry = new THREE.BoxGeometry(windowWidth, windowHeight, 0.2);
                    
                    // Random window color
                    const windowColor = Math.random() < 0.3 ? neonColor : 0x88ccff;
                    const windowMaterial = new THREE.MeshPhongMaterial({
                        color: 0x222222,
                        emissive: windowColor,
                        emissiveIntensity: 0.8 + Math.random() * 0.4,
                        transparent: true,
                        opacity: 0.9
                    });
                    
                    const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                    
                    // Position randomly on one of the four sides
                    const side = Math.floor(Math.random() * 4);
                    let xPos, yPos, zPos;
                    
                    // Calculate y position (height) - avoid very top and bottom
                    yPos = (Math.random() * 0.7 + 0.15) * height - height/2;
                    
                    if (side === 0) { // Front
                        xPos = (Math.random() * 0.8 - 0.4) * width;
                        zPos = depth/2 + 0.1;
                        windowMesh.rotation.y = 0;
                    } else if (side === 1) { // Right
                        xPos = width/2 + 0.1;
                        zPos = (Math.random() * 0.8 - 0.4) * depth;
                        windowMesh.rotation.y = Math.PI / 2;
                    } else if (side === 2) { // Back
                        xPos = (Math.random() * 0.8 - 0.4) * width;
                        zPos = -depth/2 - 0.1;
                        windowMesh.rotation.y = Math.PI;
                    } else { // Left
                        xPos = -width/2 - 0.1;
                        zPos = (Math.random() * 0.8 - 0.4) * depth;
                        windowMesh.rotation.y = -Math.PI / 2;
                    }
                    
                    windowMesh.position.set(xPos, yPos, zPos);
                    
                    // Add animation data for flickering or pulsing
                    if (Math.random() > 0.7) {
                        windowMesh.userData = {
                            isWindow: true,
                            flickerSpeed: 0.5 + Math.random() * 2.0,
                            time: Math.random() * Math.PI * 2,
                            originalIntensity: windowMaterial.emissiveIntensity
                        };
                    }
                    
                    buildingGroup.add(windowMesh);
                }
            }
            
            // Add a point light inside some buildings to create light spill effect
            if (Math.random() > 0.7 && height > 10) {
                const light = new THREE.PointLight(
                    Math.random() < 0.3 ? neonColor : 0x88ccff, 
                    0.8, // Intensity
                    width * 1.5 // Distance
                );
                light.position.set(0, 0, 0); // Center of building
                buildingGroup.add(light);
            }
            
            // Replace the original mesh with the group
            buildingMesh.position.set(0, 0, 0); // Reset position within group
            
            // Return the group instead of the original mesh
            return buildingGroup;
        }
        
        // Add a function to create street lights
        function addStreetLight(segment, isMainRoad = true) {
            // Create a street light with cyberpunk styling
            const streetLight = new THREE.Group();
            
            // Use one of the neon colors for the light
            const neonColors = themeSettings[theme].neonColors;
            const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            
            // Create the pole
            const poleHeight = 6 + Math.random() * 2;
            const poleGeometry = new THREE.CylinderGeometry(0.1, 0.15, poleHeight, 6);
            const poleMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                emissive: 0x111111
            });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = poleHeight / 2;
            streetLight.add(pole);
            
            // Create the arm that extends from the pole
            const armLength = 1.5 + Math.random() * 1.0;
            const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, armLength, 6);
            const arm = new THREE.Mesh(armGeometry, poleMaterial);
            arm.position.set(armLength/2, poleHeight - 0.5, 0);
            arm.rotation.z = Math.PI / 2;
            streetLight.add(arm);
            
            // Create the light fixture
            const fixtureGeometry = new THREE.CylinderGeometry(0.3, 0.5, 0.4, 8);
            const fixtureMaterial = new THREE.MeshPhongMaterial({
                color: 0x222222,
                emissive: neonColor,
                emissiveIntensity: 0.4
            });
            const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);
            fixture.position.set(armLength, poleHeight - 0.5, 0);
            fixture.rotation.x = Math.PI / 2;
            streetLight.add(fixture);
            
            // Add a point light
            const light = new THREE.PointLight(neonColor, 1.0, 15);
            light.position.set(armLength, poleHeight - 0.7, 0);
            
            // Add animation data for flickering
            light.userData = {
                flickerSpeed: 0.2 + Math.random() * 0.3,
                time: Math.random() * Math.PI * 2,
                originalIntensity: 1.0
            };
            
            streetLight.add(light);
            
            // Calculate track direction for positioning
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Position along track
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Position to the side of the track
            const sideOffset = isMainRoad ? trackWidth * 0.6 : 3;
            const side = Math.random() > 0.5 ? 1 : -1;
            
            // Calculate final position
            const posX = segment.start.x + dirX * alongTrack + perpX * sideOffset * side;
            const posZ = segment.start.z + dirZ * alongTrack + perpZ * sideOffset * side;
            
            // Rotate to face the road
            const angle = Math.atan2(dirZ, dirX) + (side > 0 ? Math.PI : 0);
            
            streetLight.position.set(posX, 0, posZ);
            streetLight.rotation.y = angle;
            
            // Enable shadows
            streetLight.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            scene.add(streetLight);
            
            // Add to environment objects
            environmentObjects.push({
                mesh: streetLight,
                type: 'streetLight',
                segment: track.length - 1
            });
        }
        
        // Function to create additional roads branching from the main track
        function addCityRoad(segment) {
            // Only add city roads occasionally
            if (Math.random() > 0.3) return;
            
            // Calculate track direction
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Decide which side to branch from
            const side = Math.random() > 0.5 ? 1 : -1;
            
            // Position along track where the city road will branch off
            const alongTrack = Math.random() * 0.6 + 0.2;
            
            // Calculate intersection point
            const intersectionX = segment.start.x + dirX * alongTrack;
            const intersectionZ = segment.start.z + dirZ * alongTrack;
            
            // Create a road that branches off perpendicular to the main track
            const roadLength = 30 + Math.random() * 50;
            const roadWidth = 8;
            
            // Create road mesh
            const roadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
            const roadMaterial = createTrackMaterial(); // Reuse the track material function
            
            const roadMesh = new THREE.Mesh(roadGeometry, roadMaterial);
            roadMesh.rotation.x = -Math.PI / 2;
            
            // Position the road
            roadMesh.position.set(
                intersectionX + perpX * side * roadLength / 2,
                0.01, // Slight elevation to prevent z-fighting
                intersectionZ + perpZ * side * roadLength / 2
            );
            
            // Rotate the road to be perpendicular to the main track
            const roadAngle = Math.atan2(perpZ, perpX);
            roadMesh.rotation.y = roadAngle;
            
            roadMesh.receiveShadow = true;
            scene.add(roadMesh);
            
            // Add to environment objects
            environmentObjects.push({
                mesh: roadMesh,
                type: 'cityRoad',
                segment: track.length - 1
            });
            
            // Add buildings along the city road
            const buildingCount = Math.floor(roadLength / 15);
            
            for (let i = 0; i < buildingCount; i++) {
                // Create a fake segment object for positioning buildings
                const buildingSegment = {
                    start: {
                        x: intersectionX,
                        z: intersectionZ
                    },
                    end: {
                        x: intersectionX + perpX * side * roadLength,
                        z: intersectionZ + perpZ * side * roadLength
                    }
                };
                
                // Position along the city road
                const buildingAlongRoad = (i + 1) / (buildingCount + 1);
                
                // Create a building
                const buildingX = intersectionX + perpX * side * roadLength * buildingAlongRoad;
                const buildingZ = intersectionZ + perpZ * side * roadLength * buildingAlongRoad;
                
                // Create a fake segment for the building position
                const buildingPositionSegment = {
                    start: {
                        x: buildingX - perpX * 5,
                        z: buildingZ - perpZ * 5
                    },
                    end: {
                        x: buildingX + perpX * 5,
                        z: buildingZ + perpZ * 5
                    }
                };
                
                // Add a building
                addEnvironmentObject(buildingPositionSegment, 'building');
                
                // Add street lights along the city road
                if (Math.random() > 0.5) {
                    const lightSegment = {
                        start: {
                            x: buildingX - perpX * 5,
                            z: buildingZ - perpZ * 5
                        },
                        end: {
                            x: buildingX + perpX * 5,
                            z: buildingZ + perpZ * 5
                        }
                    };
                    
                    addStreetLight(lightSegment, false);
                }
                
                // Add billboards along the city road
                if (Math.random() > 0.7) {
                    const billboardSegment = {
                        start: {
                            x: buildingX - perpX * 5,
                            z: buildingZ - perpZ * 5
                        },
                        end: {
                            x: buildingX + perpX * 5,
                            z: buildingZ + perpZ * 5
                        }
                    };
                    
                    addCyberpunkBillboard(billboardSegment, false);
                }
                
                // Add holographic ads along the city road
                if (Math.random() > 0.8) {
                    const holoSegment = {
                        start: {
                            x: buildingX - perpX * 5,
                            z: buildingZ - perpZ * 5
                        },
                        end: {
                            x: buildingX + perpX * 5,
                            z: buildingZ + perpZ * 5
                        }
                    };
                    
                    addHolographicAd(holoSegment, false);
                }
            }
        }
        
        // Function to create cyberpunk signage and billboards
        function addCyberpunkSignage(segment, isMainRoad = true) {
            // Use one of the neon colors for the sign
            const neonColors = themeSettings[theme].neonColors;
            const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            
            // Choose a random sign type
            const signType = Math.floor(Math.random() * 4); // 4 different sign types
            let sign;
            
            if (signType === 0) {
                // Type 1: Neon billboard attached to a building or pole
                sign = new THREE.Group();
                
                // Create the billboard base
                const billboardWidth = 3 + Math.random() * 4;
                const billboardHeight = 2 + Math.random() * 2;
                const billboardGeometry = new THREE.BoxGeometry(billboardWidth, billboardHeight, 0.2);
                const billboardMaterial = new THREE.MeshPhongMaterial({
                    color: 0x111111,
                    emissive: 0x222222,
                    emissiveIntensity: 0.2
                });
                
                const billboard = new THREE.Mesh(billboardGeometry, billboardMaterial);
                sign.add(billboard);
                
                // Create neon text/border using tubes
                const borderWidth = billboardWidth * 0.9;
                const borderHeight = billboardHeight * 0.9;
                
                // Create a neon border
                const borderGeometry = new THREE.BoxGeometry(borderWidth, borderHeight, 0.05);
                const borderMaterial = new THREE.MeshPhongMaterial({
                    color: 0x000000,
                    emissive: neonColor,
                    emissiveIntensity: 1.0,
                    transparent: true,
                    opacity: 0.9
                });
                
                // Create a wireframe border instead of a solid one
                const border = new THREE.Mesh(borderGeometry, borderMaterial);
                border.position.z = 0.15;
                
                // Make it a wireframe for neon tube effect
                const edgesGeometry = new THREE.EdgesGeometry(borderGeometry);
                const edgesMaterial = new THREE.LineBasicMaterial({ 
                    color: neonColor,
                    linewidth: 2
                });
                const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
                edges.position.z = 0.15;
                sign.add(edges);
                
                // Add random "text" using simple shapes with neon colors
                const textElements = Math.floor(Math.random() * 3) + 2; // 2-4 text elements
                
                for (let i = 0; i < textElements; i++) {
                    // Choose a random shape for "text"
                    const textShape = Math.floor(Math.random() * 3);
                    let textGeometry;
                    
                    if (textShape === 0) {
                        // Horizontal bar
                        textGeometry = new THREE.BoxGeometry(
                            0.5 + Math.random() * (borderWidth * 0.7),
                            0.2 + Math.random() * 0.3,
                            0.1
                        );
                    } else if (textShape === 1) {
                        // Vertical bar
                        textGeometry = new THREE.BoxGeometry(
                            0.2 + Math.random() * 0.3,
                            0.5 + Math.random() * (borderHeight * 0.7),
                            0.1
                        );
                    } else {
                        // Circle/dot
                        textGeometry = new THREE.CircleGeometry(
                            0.2 + Math.random() * 0.4,
                            8
                        );
                    }
                    
                    // Use a different neon color for each text element
                    const textNeonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                    const textMaterial = new THREE.MeshPhongMaterial({
                        color: 0x000000,
                        emissive: textNeonColor,
                        emissiveIntensity: 1.2,
                        side: THREE.DoubleSide
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    // Position randomly within the billboard
                    textMesh.position.set(
                        (Math.random() - 0.5) * (borderWidth * 0.8),
                        (Math.random() - 0.5) * (borderHeight * 0.8),
                        0.2
                    );
                    
                    // Add animation data
                    textMesh.userData = {
                        isNeonSign: true,
                        flickerSpeed: 0.5 + Math.random() * 2.0,
                        time: Math.random() * Math.PI * 2,
                        originalIntensity: textMaterial.emissiveIntensity
                    };
                    
                    sign.add(textMesh);
                }
                
                // Create a pole if it's a standalone sign
                if (Math.random() > 0.5) {
                    const poleHeight = 5 + Math.random() * 3;
                    const poleGeometry = new THREE.CylinderGeometry(0.15, 0.15, poleHeight, 6);
                    const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
                    const pole = new THREE.Mesh(poleGeometry, poleMaterial);
                    
                    // Position the pole below the billboard
                    pole.position.set(0, -billboardHeight/2 - poleHeight/2, 0);
                    sign.add(pole);
                    
                    // Adjust the sign height
                    sign.position.y = poleHeight + billboardHeight/2;
                } else {
                    // It's attached to a building, position it higher
                    sign.position.y = 5 + Math.random() * 10;
                }
                
            } else if (signType === 1) {
                // Type 2: Floating holographic advertisement
                sign = new THREE.Group();
                
                // Create a holographic display emitter (base)
                const emitterGeometry = new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8);
                const emitterMaterial = new THREE.MeshPhongMaterial({
                    color: 0x222222,
                    emissive: neonColor,
                    emissiveIntensity: 0.5
                });
                
                const emitter = new THREE.Mesh(emitterGeometry, emitterMaterial);
                emitter.position.y = 0.25;
                sign.add(emitter);
                
                // Create holographic panels
                const panelCount = Math.floor(Math.random() * 2) + 1; // 1-2 panels
                
                for (let i = 0; i < panelCount; i++) {
                    const panelWidth = 2 + Math.random() * 3;
                    const panelHeight = 1.5 + Math.random() * 2;
                    const panelGeometry = new THREE.PlaneGeometry(panelWidth, panelHeight);
                    
                    // Create a canvas for the holographic texture
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');
                    
                    // Fill with transparent base
                    ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Add grid lines for tech feel
                    ctx.strokeStyle = '#' + neonColor.toString(16).padStart(6, '0');
                    ctx.lineWidth = 1;
                    
                    // Horizontal grid lines
                    for (let y = 0; y < canvas.height; y += 16) {
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(canvas.width, y);
                        ctx.stroke();
                    }
                    
                    // Vertical grid lines
                    for (let x = 0; x < canvas.width; x += 16) {
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, canvas.height);
                        ctx.stroke();
                    }
                    
                    // Add some random shapes for "text"
                    ctx.fillStyle = '#' + neonColor.toString(16).padStart(6, '0');
                    
                    for (let j = 0; j < 5; j++) {
                        const shapeType = Math.floor(Math.random() * 3);
                        const x = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                        const y = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                        const size = 10 + Math.random() * 40;
                        
                        if (shapeType === 0) {
                            // Rectangle
                            ctx.fillRect(x, y, size, size / 2);
                        } else if (shapeType === 1) {
                            // Circle
                            ctx.beginPath();
                            ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            // Triangle
                            ctx.beginPath();
                            ctx.moveTo(x, y - size / 2);
                            ctx.lineTo(x + size / 2, y + size / 2);
                            ctx.lineTo(x - size / 2, y + size / 2);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                    
                    // Create texture from canvas
                    const texture = new THREE.CanvasTexture(canvas);
                    
                    const panelMaterial = new THREE.MeshPhongMaterial({
                        color: 0xffffff,
                        emissive: neonColor,
                        emissiveIntensity: 0.5,
                        map: texture,
                        transparent: true,
                        opacity: 0.7,
                        side: THREE.DoubleSide
                    });
                    
                    const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                    
                    // Position above the emitter
                    panel.position.y = 2 + i * 0.5;
                    
                    // Add animation data
                    panel.userData = {
                        isHologram: true,
                        rotationSpeed: 0.2 + Math.random() * 0.3,
                        pulseSpeed: 0.5 + Math.random() * 1.0,
                        time: Math.random() * Math.PI * 2,
                        originalOpacity: panelMaterial.opacity
                    };
                    
                    sign.add(panel);
                }
                
                // Position the holographic sign
                sign.position.y = 0.5;
                
            } else if (signType === 2) {
                // Type 3: Neon shop sign attached to a building
                sign = new THREE.Group();
                
                // Create the sign base
                const signWidth = 2 + Math.random() * 3;
                const signHeight = 0.8 + Math.random() * 1.2;
                const signGeometry = new THREE.BoxGeometry(signWidth, signHeight, 0.2);
                const signMaterial = new THREE.MeshPhongMaterial({
                    color: 0x111111
                });
                
                const signBase = new THREE.Mesh(signGeometry, signMaterial);
                sign.add(signBase);
                
                // Create neon text using simple shapes
                const textElements = Math.floor(Math.random() * 3) + 1; // 1-3 text elements
                
                for (let i = 0; i < textElements; i++) {
                    // Choose a random shape for "text"
                    const textShape = Math.floor(Math.random() * 3);
                    let textGeometry;
                    
                    if (textShape === 0) {
                        // Horizontal bar
                        textGeometry = new THREE.BoxGeometry(
                            signWidth * 0.7,
                            0.1,
                            0.05
                        );
                    } else if (textShape === 1) {
                        // Circle
                        textGeometry = new THREE.TorusGeometry(
                            signHeight * 0.3,
                            0.05,
                            8,
                            16
                        );
                    } else {
                        // Custom shape (e.g., arrow)
                        const shape = new THREE.Shape();
                        shape.moveTo(0, 0);
                        shape.lineTo(0.5, 0.5);
                        shape.lineTo(0, 0.3);
                        shape.lineTo(-0.5, 0.5);
                        shape.lineTo(0, 0);
                        
                        textGeometry = new THREE.ShapeGeometry(shape);
                        textGeometry.scale(signHeight * 0.8, signHeight * 0.8, 1);
                    }
                    
                    // Use a neon color
                    const textNeonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                    const textMaterial = new THREE.MeshPhongMaterial({
                        color: 0x000000,
                        emissive: textNeonColor,
                        emissiveIntensity: 1.0
                    });
                    
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                    
                    // Position on the sign
                    textMesh.position.z = 0.15;
                    
                    // Offset each element
                    textMesh.position.x = (i - (textElements-1)/2) * (signWidth * 0.6 / Math.max(1, textElements-1));
                    
                    // Add animation data
                    textMesh.userData = {
                        isNeonSign: true,
                        flickerSpeed: 0.3 + Math.random() * 1.5,
                        time: Math.random() * Math.PI * 2,
                        originalIntensity: textMaterial.emissiveIntensity
                    };
                    
                    sign.add(textMesh);
                }
                
                // Position the sign (will be adjusted later based on placement)
                sign.position.y = 3 + Math.random() * 8;
                
            } else {
                // Type 4: Floating cyberpunk drone/ad platform
                sign = new THREE.Group();
                
                // Create the drone body
                const bodyGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const bodyMaterial = new THREE.MeshPhongMaterial({
                    color: 0x222222,
                    emissive: neonColor,
                    emissiveIntensity: 0.3
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                sign.add(body);
                
                // Add propellers/antigrav units
                const propCount = 3 + Math.floor(Math.random() * 2); // 3-4 props
                
                for (let i = 0; i < propCount; i++) {
                    const angle = (i / propCount) * Math.PI * 2;
                    const propGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 8);
                    const propMaterial = new THREE.MeshPhongMaterial({
                        color: 0x333333,
                        emissive: neonColor,
                        emissiveIntensity: 0.5
                    });
                    
                    const prop = new THREE.Mesh(propGeometry, propMaterial);
                    
                    // Position around the body
                    prop.position.set(
                        Math.sin(angle) * 0.7,
                        0,
                        Math.cos(angle) * 0.7
                    );
                    
                    // Add a small light
                    const propLight = new THREE.PointLight(neonColor, 0.5, 3);
                    propLight.position.set(0, 0, 0);
                    prop.add(propLight);
                    
                    // Add animation data
                    prop.userData = {
                        isDroneProp: true,
                        rotationSpeed: 3 + Math.random() * 2,
                        time: Math.random() * Math.PI * 2
                    };
                    
                    sign.add(prop);
                }
                
                // Add a holographic display
                const displayGeometry = new THREE.PlaneGeometry(2, 1);
                
                // Create a canvas for the display
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                // Fill with base color
                ctx.fillStyle = '#' + neonColor.toString(16).padStart(6, '0');
                ctx.globalAlpha = 0.3;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add some random shapes for "text"
                ctx.globalAlpha = 0.8;
                ctx.fillStyle = '#ffffff';
                
                for (let j = 0; j < 3; j++) {
                    const x = 20 + j * 80;
                    const y = canvas.height / 2;
                    const size = 20 + Math.random() * 20;
                    
                    // Simple shapes for "text"
                    ctx.fillRect(x, y - size/2, size, size/2);
                }
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                
                const displayMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.5,
                    map: texture,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                
                const display = new THREE.Mesh(displayGeometry, displayMaterial);
                display.position.y = 0.8;
                
                // Add animation data
                display.userData = {
                    isHologram: true,
                    pulseSpeed: 0.5 + Math.random() * 1.0,
                    time: Math.random() * Math.PI * 2,
                    originalOpacity: displayMaterial.opacity
                };
                
                sign.add(display);
                
                // Position the drone
                sign.position.y = 5 + Math.random() * 10;
                
                // Add animation data for the entire drone
                sign.userData = {
                    isDrone: true,
                    hoverSpeed: 0.2 + Math.random() * 0.3,
                    hoverHeight: 0.2 + Math.random() * 0.3,
                    time: Math.random() * Math.PI * 2,
                    baseY: sign.position.y
                };
            }
            
            // Calculate track direction for positioning
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Position along track
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Position to the side of the track
            let sideOffset;
            if (isMainRoad) {
                sideOffset = (10 + Math.random() * 15) * (Math.random() > 0.5 ? 1 : -1);
            } else {
                sideOffset = (5 + Math.random() * 8) * (Math.random() > 0.5 ? 1 : -1);
            }
            
            // Calculate final position
            const posX = segment.start.x + dirX * alongTrack + perpX * sideOffset;
            const posZ = segment.start.z + dirZ * alongTrack + perpZ * sideOffset;
            
            // Set position
            sign.position.x = posX;
            sign.position.z = posZ;
            
            // Rotate to face the road
            const angle = Math.atan2(dirZ, dirX) + (sideOffset > 0 ? Math.PI : 0);
            sign.rotation.y = angle;
            
            // Enable shadows
            sign.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            scene.add(sign);
            
            // Add to environment objects
            environmentObjects.push({
                mesh: sign,
                type: 'signage',
                segment: track.length - 1
            });
        }
        
        // Function to create cyberpunk billboards
        function addCyberpunkBillboard(segment, isMainRoad = true) {
            // Create a billboard with cyberpunk styling
            const billboard = new THREE.Group();
            
            // Use one of the neon colors for the sign
            const neonColors = themeSettings[theme].neonColors;
            const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            
            // Create the billboard base
            const billboardWidth = 3 + Math.random() * 4;
            const billboardHeight = 2 + Math.random() * 2;
            const billboardGeometry = new THREE.BoxGeometry(billboardWidth, billboardHeight, 0.2);
            const billboardMaterial = new THREE.MeshPhongMaterial({
                color: 0x111111,
                emissive: 0x222222,
                emissiveIntensity: 0.2
            });
            
            const billboardMesh = new THREE.Mesh(billboardGeometry, billboardMaterial);
            billboard.add(billboardMesh);
            
            // Create neon border
            const borderWidth = billboardWidth * 0.9;
            const borderHeight = billboardHeight * 0.9;
            const borderGeometry = new THREE.BoxGeometry(borderWidth, borderHeight, 0.05);
            const borderMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                emissive: neonColor,
                emissiveIntensity: 1.0
            });
            
            const border = new THREE.Mesh(borderGeometry, borderMaterial);
            border.position.z = 0.15;
            billboard.add(border);
            
            // Add random "text" using simple shapes with neon colors
            const textElements = Math.floor(Math.random() * 3) + 2; // 2-4 text elements
            
            for (let i = 0; i < textElements; i++) {
                // Create a simple box for text
                const textGeometry = new THREE.BoxGeometry(
                    0.5 + Math.random() * (borderWidth * 0.7),
                    0.2 + Math.random() * 0.3,
                    0.1
                );
                
                // Use a different neon color for each text element
                const textNeonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                const textMaterial = new THREE.MeshPhongMaterial({
                    color: 0x000000,
                    emissive: textNeonColor,
                    emissiveIntensity: 1.2
                });
                
                const textMesh = new THREE.Mesh(textGeometry, textMaterial);
                
                // Position randomly within the billboard
                textMesh.position.set(
                    (Math.random() - 0.5) * (borderWidth * 0.8),
                    (Math.random() - 0.5) * (borderHeight * 0.8),
                    0.2
                );
                
                // Add animation data
                textMesh.userData = {
                    isNeonSign: true,
                    flickerSpeed: 0.5 + Math.random() * 2.0,
                    time: Math.random() * Math.PI * 2,
                    originalIntensity: textMaterial.emissiveIntensity
                };
                
                billboard.add(textMesh);
            }
            
            // Create a pole
            const poleHeight = 5 + Math.random() * 3;
            const poleGeometry = new THREE.CylinderGeometry(0.15, 0.15, poleHeight, 6);
            const poleMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            
            // Position the pole below the billboard
            pole.position.set(0, -billboardHeight/2 - poleHeight/2, 0);
            billboard.add(pole);
            
            // Adjust the billboard height
            billboard.position.y = poleHeight + billboardHeight/2;
            
            // Calculate track direction for positioning
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Position along track
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Position to the side of the track
            let sideOffset;
            if (isMainRoad) {
                sideOffset = (10 + Math.random() * 15) * (Math.random() > 0.5 ? 1 : -1);
            } else {
                sideOffset = (5 + Math.random() * 8) * (Math.random() > 0.5 ? 1 : -1);
            }
            
            // Calculate final position
            const posX = segment.start.x + dirX * alongTrack + perpX * sideOffset;
            const posZ = segment.start.z + dirZ * alongTrack + perpZ * sideOffset;
            
            // Set position
            billboard.position.x = posX;
            billboard.position.z = posZ;
            
            // Rotate to face the road
            const angle = Math.atan2(dirZ, dirX) + (sideOffset > 0 ? Math.PI : 0);
            billboard.rotation.y = angle;
            
            // Enable shadows
            billboard.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            scene.add(billboard);
            
            // Add to environment objects
            environmentObjects.push({
                mesh: billboard,
                type: 'billboard',
                segment: track.length - 1
            });
        }
        
        // Function to create holographic advertisements
        function addHolographicAd(segment, isMainRoad = true) {
            // Create a holographic advertisement
            const holoAd = new THREE.Group();
            
            // Use one of the neon colors for the hologram
            const neonColors = themeSettings[theme].neonColors;
            const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
            
            // Create a holographic display emitter (base)
            const emitterGeometry = new THREE.CylinderGeometry(0.3, 0.5, 0.5, 8);
            const emitterMaterial = new THREE.MeshPhongMaterial({
                color: 0x222222,
                emissive: neonColor,
                emissiveIntensity: 0.5
            });
            
            const emitter = new THREE.Mesh(emitterGeometry, emitterMaterial);
            emitter.position.y = 0.25;
            holoAd.add(emitter);
            
            // Create holographic panels
            const panelCount = Math.floor(Math.random() * 2) + 1; // 1-2 panels
            
            for (let i = 0; i < panelCount; i++) {
                const panelWidth = 2 + Math.random() * 3;
                const panelHeight = 1.5 + Math.random() * 2;
                const panelGeometry = new THREE.PlaneGeometry(panelWidth, panelHeight);
                
                // Create a canvas for the holographic texture
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                // Fill with transparent base
                ctx.fillStyle = 'rgba(0, 0, 0, 0)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Add grid lines for tech feel
                ctx.strokeStyle = '#' + neonColor.toString(16).padStart(6, '0');
                ctx.lineWidth = 1;
                
                // Horizontal grid lines
                for (let y = 0; y < canvas.height; y += 16) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
                
                // Vertical grid lines
                for (let x = 0; x < canvas.width; x += 16) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }
                
                // Add some random shapes for "text"
                ctx.fillStyle = '#' + neonColor.toString(16).padStart(6, '0');
                
                for (let j = 0; j < 5; j++) {
                    const shapeType = Math.floor(Math.random() * 3);
                    const x = Math.random() * canvas.width * 0.8 + canvas.width * 0.1;
                    const y = Math.random() * canvas.height * 0.8 + canvas.height * 0.1;
                    const size = 10 + Math.random() * 40;
                    
                    if (shapeType === 0) {
                        // Rectangle
                        ctx.fillRect(x, y, size, size / 2);
                    } else if (shapeType === 1) {
                        // Circle
                        ctx.beginPath();
                        ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Triangle
                        ctx.beginPath();
                        ctx.moveTo(x, y - size / 2);
                        ctx.lineTo(x + size / 2, y + size / 2);
                        ctx.lineTo(x - size / 2, y + size / 2);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                
                const panelMaterial = new THREE.MeshPhongMaterial({
                    color: 0xffffff,
                    emissive: neonColor,
                    emissiveIntensity: 0.5,
                    map: texture,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                
                const panel = new THREE.Mesh(panelGeometry, panelMaterial);
                
                // Position above the emitter
                panel.position.y = 2 + i * 0.5;
                
                // Add animation data
                panel.userData = {
                    isHologram: true,
                    rotationSpeed: 0.2 + Math.random() * 0.3,
                    pulseSpeed: 0.5 + Math.random() * 1.0,
                    time: Math.random() * Math.PI * 2,
                    originalOpacity: panelMaterial.opacity
                };
                
                holoAd.add(panel);
            }
            
            // Add a point light for the hologram
            const light = new THREE.PointLight(neonColor, 0.8, 5);
            light.position.y = 2;
            holoAd.add(light);
            
            // Calculate track direction for positioning
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Position along track
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Position to the side of the track
            let sideOffset;
            if (isMainRoad) {
                sideOffset = (8 + Math.random() * 12) * (Math.random() > 0.5 ? 1 : -1);
            } else {
                sideOffset = (4 + Math.random() * 6) * (Math.random() > 0.5 ? 1 : -1);
            }
            
            // Calculate final position
            const posX = segment.start.x + dirX * alongTrack + perpX * sideOffset;
            const posZ = segment.start.z + dirZ * alongTrack + perpZ * sideOffset;
            
            // Set position
            holoAd.position.x = posX;
            holoAd.position.z = posZ;
            
            // Rotate to face the road
            const angle = Math.atan2(dirZ, dirX) + (sideOffset > 0 ? Math.PI : 0);
            holoAd.rotation.y = angle;
            
            // Enable shadows
            holoAd.traverse(function(child) {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
            
            scene.add(holoAd);
            
            // Add to environment objects
            environmentObjects.push({
                mesh: holoAd,
                type: 'hologram',
                segment: track.length - 1
            });
        }

        // Check if car is on the track
        function isOnTrack() {
            // Calculate search bounds to limit track segments we check
            const startSegment = Math.max(0, currentSegment - 2);
            const endSegment = Math.min(track.length, currentSegment + 3);
            
            // Check if car is on any track segment
            for (let i = startSegment; i < endSegment; i++) {
                const segment = track[i];
                
                // Calculate distance from car to segment center line
                const dx = car.position.x - segment.centerX;
                const dz = car.position.z - segment.centerZ;
                
                // Project onto segment direction vector
                const dot = dx * segment.dirX + dz * segment.dirZ;
                const projX = segment.centerX + dot * segment.dirX;
                const projZ = segment.centerZ + dot * segment.dirZ;
                
                // Calculate distance to projected point
                const distX = car.position.x - projX;
                const distZ = car.position.z - projZ;
                const distance = Math.sqrt(distX * distX + distZ * distZ);
                
                if (distance < trackWidth * 0.95) { // Very forgiving track width detection
                    return true;
                }
            }
            
            return false;
        }

        // Calculate the distance from the car to the end of the track
        function getDistanceToTrackEnd() {
            if (track.length === 0) return 0;
            
            // Get the last track segment
            const lastSegment = track[track.length - 1];
            
            // Calculate the distance from the car to the end point of the last segment
            const dx = lastSegment.endX - car.position.x;
            const dz = lastSegment.endZ - car.position.z;
            
            return Math.sqrt(dx * dx + dz * dz);
        }
    </script>
</body>
</html> 