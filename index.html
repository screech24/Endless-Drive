<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Endless Drive - 3D Driving Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
        }
        #score {
            font-size: 24px;
            margin-bottom: 10px;
        }
        #speed {
            font-size: 18px;
        }
        #powerup {
            font-size: 18px;
            color: #ffcc00;
        }
        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            width: 300px;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px 5px;
            cursor: pointer;
            border-radius: 5px;
        }
        .car-select {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
        }
        .theme-select {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
            width: 300px;
        }
        
        /* Mobile Controls Styles */
        #mobileControls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none; /* Hidden by default, shown via JS for touch devices */
            pointer-events: none;
            z-index: 100;
        }
        
        .control-container {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        
        #joystickZone {
            width: 120px;
            height: 120px;
            position: relative;
            margin-left: 20px;
            pointer-events: auto;
        }
        
        .pedal-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-right: 20px;
            pointer-events: auto;
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            background-color: rgba(255, 0, 255, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
            pointer-events: auto;
        }
        
        .accelerate-btn {
            background-color: rgba(0, 255, 100, 0.6);
        }
        
        .brake-btn {
            background-color: rgba(255, 50, 50, 0.6);
        }
        
        .nitro-btn {
            background-color: rgba(255, 204, 0, 0.6);
            width: 80px;
            height: 80px;
            font-size: 16px;
            margin-bottom: 20px;
        }
        
        /* Media query for mobile devices */
        @media (max-width: 768px) {
            #menu, #gameOver {
                width: 90%;
                max-width: 300px;
            }
        }
        
        /* Landscape orientation specific styles */
        @media (orientation: landscape) {
            .control-container {
                bottom: 20px;
            }
            
            #joystickZone {
                width: 150px;
                height: 150px;
                position: absolute;
                bottom: 10px;
                left: 20px;
                margin-left: 0;
            }
            
            .pedal-controls {
                margin-right: 30px;
                position: absolute;
                right: 20px;
                bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div id="score">Distance: 0m</div>
        <div id="speed">Speed: 0 km/h</div>
        <div id="powerup"></div>
    </div>

    <div id="menu">
        <h2>Endless Drive</h2>
        <button id="startGame">Start Game</button>
        <div id="controlInstructions">
            <p><strong>Desktop Controls:</strong><br>Arrow keys or WASD to drive<br>Space to use nitro</p>
            <p><strong>Mobile Controls:</strong><br>Left joystick to steer<br>Right buttons to accelerate/brake<br>Tap NITRO button when available</p>
        </div>
    </div>

    <div id="gameOver">
        <h2>Game Over</h2>
        <div id="finalScore">Distance: 0m</div>
        <div id="highScore">High Score: 0m</div>
        <button id="shareScore">Share Score</button>
        <button id="playAgain">Play Again</button>
        <button id="mainMenu">Main Menu</button>
    </div>
    
    <!-- Mobile Controls -->
    <div id="mobileControls">
        <div class="control-container">
            <div id="joystickZone"></div>
            <div class="pedal-controls">
                <button class="control-btn nitro-btn" id="nitroBtn">NITRO</button>
                <button class="control-btn accelerate-btn" id="accelerateBtn">↑</button>
                <button class="control-btn brake-btn" id="brakeBtn">↓</button>
            </div>
        </div>
    </div>

    <!-- Add nipplejs library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, car;
        let track = [];
        let obstacles = [];
        let powerUps = [];
        let groundTiles = []; // Add array to track ground tiles
        let score = 0;
        let speed = 0;
        let maxSpeed = 0;
        let acceleration = 0;
        let steering = 0;
        let activePowerUp = null;
        let powerUpTimer = 0;
        let gameActive = false;
        let cameraOffset = new THREE.Vector3(0, 5, -10);
        let clock = new THREE.Clock();
        let highScore = localStorage.getItem('highScore') || 0;
        let carType = 'sportsCar';
        let theme = 'cyberpunk';
        let currentSegment = 0;
        let segmentLength = 50;
        let trackWidth = 10;
        let groundTileSize = 100; // Size of each ground tile
        let carSpecs = {
            sportsCar: { acceleration: 10, maxSpeed: 100, steering: 2.5, color: 0xff00ff }
        };
        let themeSettings = {
            cyberpunk: { 
                groundColor: 0x0a0a0a,
                fogColor: 0x220033,
                fogDensity: 0.015,
                skyColor: 0x000033,
                ambientLight: 0x330066,
                directionalLight: 0xff00ff,
                
                neonColors: [
                    0xff00ff,
                    0x00ffff,
                    0xff3300,
                    0x33ff00
                ]
            }
        };
        const keys = {};
        let isMobileDevice = false;
        let joystickInput = 0; // Store joystick steering input (-1 to 1)
        
        // Environment objects
        let environmentObjects = [];

        // Object pooling for performance optimization
        const objectPool = {
            groundTileTextures: [],
            trackMaterials: [], // Add track material pooling
            
            getGroundTexture: function() {
                if (this.groundTileTextures.length > 0) {
                    return this.groundTileTextures.pop();
                }
                
                // Create a new texture if none are available in the pool
                const groundCanvas = document.createElement('canvas');
                groundCanvas.width = 512; // Reduced from 1024 for better performance
                groundCanvas.height = 512; // Reduced from 1024 for better performance
                const context = groundCanvas.getContext('2d');
                
                // Fill with dark color
                context.fillStyle = '#0a0a0a';
                context.fillRect(0, 0, groundCanvas.width, groundCanvas.height);
                
                // Add grid pattern
                context.strokeStyle = '#220022';
                context.lineWidth = 1;
                
                // Draw grid with larger spacing for better performance
                const gridSize = 128; // Increased from 64 for better performance
                for (let x = 0; x < groundCanvas.width; x += gridSize) {
                    context.beginPath();
                    context.moveTo(x, 0);
                    context.lineTo(x, groundCanvas.height);
                    context.stroke();
                }
                
                for (let y = 0; y < groundCanvas.height; y += gridSize) {
                    context.beginPath();
                    context.moveTo(0, y);
                    context.lineTo(groundCanvas.width, y);
                    context.stroke();
                }
                
                const groundTexture = new THREE.CanvasTexture(groundCanvas);
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(2, 2);
                
                return groundTexture;
            },
            
            returnGroundTexture: function(texture) {
                // Only keep a reasonable pool size to prevent memory issues
                if (this.groundTileTextures.length < 10) {
                    this.groundTileTextures.push(texture);
                } else {
                    texture.dispose();
                }
            },
            
            getTrackMaterial: function() {
                if (this.trackMaterials.length > 0) {
                    return this.trackMaterials.pop();
                }
                
                return createTrackMaterial();
            },
            
            returnTrackMaterial: function(material) {
                // Only keep a reasonable pool size to prevent memory issues
                if (this.trackMaterials.length < 5) {
                    this.trackMaterials.push(material);
                } else {
                    material.dispose();
                }
            }
        };

        // Initialize - make sure we only initialize once
        let initialized = false;
        function init() {
            // Create scene
            scene = new THREE.Scene();
            
            // Set up theme
            const themeConfig = themeSettings[theme];
            scene.background = new THREE.Color(themeConfig.skyColor);
            scene.fog = new THREE.FogExp2(themeConfig.fogColor, themeConfig.fogDensity);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -10);
            camera.lookAt(0, 0, 0);
            
            // Create or update renderer
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                document.body.appendChild(renderer.domElement);
            }
            
            // Add lights - updated for cyberpunk feel with increased brightness
            const ambientLight = new THREE.AmbientLight(themeConfig.ambientLight, 1.0); // Increased intensity
            scene.add(ambientLight);
            
            // Add a general hemisphere light for better overall illumination
            const hemisphereLight = new THREE.HemisphereLight(0x8844ff, 0x002244, 0.8);
            scene.add(hemisphereLight);
            
            const directionalLight = new THREE.DirectionalLight(themeConfig.directionalLight, 1.0); // Increased intensity
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            scene.add(directionalLight);
            
            // Add more atmospheric lighting for cyberpunk theme
            addCyberpunkLighting();
            
            // Create car (after lighting setup)
            createCar();
            
            // Generate initial track
            generateInitialTrack();
            
            // Handle window resize and controls only once
            if (!initialized) {
                window.addEventListener('resize', onWindowResize);
                document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
                document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
                
                // Set up mobile controls
                setupMobileControls();
                
                initialized = true;
                
                // Start animation loop
                animate();
            }
        }
        
        function createCar() {
            const specs = carSpecs[carType];
            acceleration = specs.acceleration;
            maxSpeed = specs.maxSpeed;
            steering = specs.steering;
            
            // Create car mesh (simplified)
            const carGeometry = new THREE.BoxGeometry(2, 1, 4);
            const carMaterial = new THREE.MeshPhongMaterial({ color: specs.color });
            car = new THREE.Mesh(carGeometry, carMaterial);
            car.castShadow = true;
            car.receiveShadow = true;
            // Ensure car is always created at the start position
            car.position.set(0, 0.5, 0);
            car.rotation.y = 0; // Reset rotation
            scene.add(car);
            
            // Add wheels (simplified) - fix wheel orientation
            const wheelGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 16);
            // Rotate cylinder to align with car
            wheelGeometry.rotateZ(Math.PI / 2);
            const wheelMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
            
            const frontLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontLeftWheel.position.set(-1.1, -0.3, 1.5);
            car.add(frontLeftWheel);
            
            const frontRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontRightWheel.position.set(1.1, -0.3, 1.5);
            car.add(frontRightWheel);
            
            const backLeftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backLeftWheel.position.set(-1.1, -0.3, -1.5);
            car.add(backLeftWheel);
            
            const backRightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            backRightWheel.position.set(1.1, -0.3, -1.5);
            car.add(backRightWheel);
            
            // Find and update the spotlight to target the car after it's created
            environmentObjects.forEach(obj => {
                if (obj.type === 'spotlight' && obj.mesh) {
                    obj.mesh.target = car;
                }
            });
        }
        
        function addCyberpunkLighting() {
            // Add point lights with neon colors along the track
            const themeConfig = themeSettings[theme];
            
            // Add a pulsing global light with increased range and intensity
            const pulsingLight = new THREE.PointLight(0xff00ff, 1.5, 200); // Increased intensity and range
            pulsingLight.position.set(0, 30, 0);
            pulsingLight.userData = { 
                phase: Math.random() * Math.PI * 2,
                speed: 0.5 + Math.random() * 0.5,
                initialIntensity: 1.5
            };
            scene.add(pulsingLight);
            
            // Create a brighter spotlight to follow the car (initialized with safe position before car is created)
            const spotlight = new THREE.SpotLight(0x00ffff, 1.5, 100, Math.PI / 6, 0.5); // Increased intensity and range
            spotlight.position.set(0, 20, -5);
            // Will set spotlight target to car later when car is available
            spotlight.castShadow = true;
            scene.add(spotlight);
            
            // Add 4 more point lights around the starting area for initial visibility
            const colors = themeConfig.neonColors;
            
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const x = Math.sin(angle) * 20;
                const z = Math.cos(angle) * 20;
                
                const pointLight = new THREE.PointLight(colors[i], 1.0, 50);
                pointLight.position.set(x, 5, z);
                scene.add(pointLight);
                
                environmentObjects.push({
                    type: 'staticLight',
                    mesh: pointLight,
                    segment: 0 // Attach to first segment
                });
            }
            
            // Store these lights for animation
            environmentObjects.push({ 
                type: 'pulsingLight', 
                mesh: pulsingLight 
            });
            
            environmentObjects.push({ 
                type: 'spotlight', 
                mesh: spotlight 
            });
        }
        
        function generateInitialTrack() {
            // Create initial ground tiles instead of a single large plane
            createInitialGroundTiles();
            
            // Generate first few track segments
            for (let i = 0; i < 10; i++) {
                addTrackSegment();
            }
        }
        
        function createInitialGroundTiles() {
            // Create the initial set of ground tiles around the starting area
            for (let x = -1; x <= 1; x++) {
                for (let z = -1; z <= 1; z++) {
                    createGroundTile(x * groundTileSize, z * groundTileSize);
                }
            }
        }
        
        function createGroundTile(centerX, centerZ) {
            // Create a ground tile centered at the given position
            const groundGeometry = new THREE.PlaneGeometry(groundTileSize, groundTileSize);
            
            // Use texture from object pool for better performance
            const groundTexture = objectPool.getGroundTexture();
            
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: themeSettings[theme].groundColor,
                map: groundTexture,
                side: THREE.DoubleSide,
                emissive: 0x110022,
                emissiveIntensity: 0.1
            });
            
            const groundTile = new THREE.Mesh(groundGeometry, groundMaterial);
            
            // Use quaternion for ground rotation to maintain consistency with track segments
            const groundRotation = new THREE.Quaternion();
            groundRotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
            groundTile.quaternion.copy(groundRotation);
            
            // Position the ground tile at the specified center
            groundTile.position.set(centerX, 0, centerZ);
            
            groundTile.receiveShadow = true;
            scene.add(groundTile);
            
            // Store the ground tile reference
            groundTiles.push({
                mesh: groundTile,
                x: centerX,
                z: centerZ,
                texture: groundTexture // Store reference to return to pool later
            });
            
            return groundTile;
        }
        
        function addTrackSegment() {
            // Always create straight segments only
            const segmentType = 'straight';
            
            let lastPoint = { x: 0, z: 0 };
            let lastRotation = 0;
            
            if (track.length > 0) {
                const lastSegment = track[track.length - 1];
                lastPoint = { x: lastSegment.end.x, z: lastSegment.end.z };
                lastRotation = lastSegment.endRotation;
            }
            
            // Use a global sequentialSegmentId to keep sequential numbering even as segments are removed
            if (typeof window.sequentialSegmentId === 'undefined') {
                window.sequentialSegmentId = 0;
            }
            
            const segment = {
                start: { x: lastPoint.x, z: lastPoint.z },
                startRotation: lastRotation,
                type: segmentType,
                segment: window.sequentialSegmentId++, // Use the sequential ID instead of array length
                arrayIndex: track.length // Store the initial array index separately
            };
            
            // Create the straight track segment
            segment.end = {
                x: lastPoint.x + segmentLength * Math.sin(lastRotation),
                z: lastPoint.z + segmentLength * Math.cos(lastRotation)
            };
            segment.endRotation = lastRotation;
            
            // Create the straight track segment
            const trackGeometry = new THREE.PlaneGeometry(trackWidth * 1.2, segmentLength * 1.15); // Increase width and length for better coverage
            // Get material from pool for better performance
            const trackMaterial = objectPool.getTrackMaterial();
            
            const trackMesh = new THREE.Mesh(trackGeometry, trackMaterial);
            
            // Position at the midpoint between start and end
            trackMesh.position.set(
                (segment.start.x + segment.end.x) / 2,
                0.02, // Slight elevation to prevent z-fighting
                (segment.start.z + segment.end.z) / 2
            );
            
            // Use quaternions for rotation
            const flatRotation = new THREE.Quaternion();
            flatRotation.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2);
            
            const directionRotation = new THREE.Quaternion();
            directionRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), segment.startRotation);
            
            // Apply rotations in the correct order: first direction, then flatten
            trackMesh.quaternion.copy(flatRotation);
            trackMesh.quaternion.premultiply(directionRotation);
            
            scene.add(trackMesh);
            // Store track material reference for cleanup
            segment.mesh = trackMesh;
            segment.material = trackMaterial;
            
            // Add environment objects on the sides of the straight track
            if (Math.random() < 0.7) {
                addEnvironmentObject(segment, 'building');
            }
            
            if (Math.random() < 0.6) {
                addEnvironmentObject(segment, 'tree');
            }
            
            if (Math.random() < 0.4) {
                addEnvironmentObject(segment, 'debris');
            }
            
            track.push(segment);
            
            // Add random obstacles and power-ups on this segment, but avoid the start
            const isFirstSegment = track.length === 1;
            
            // Don't add obstacles on the first few segments to give player time to adjust
            if (!isFirstSegment && track.length > 3 && Math.random() < 0.4) {
                addObstacle(segment);
            }
            
            // Add power-ups, but less frequently and not on the first few segments
            if (!isFirstSegment && track.length > 5 && Math.random() < 0.3) {
                addPowerUp(segment);
            }
            
            // After adding a track segment, check if we need to add ground tiles
            checkAndCreateGroundTiles();
        }
        
        function checkAndCreateGroundTiles() {
            if (track.length === 0) return;
            
            // Get the end point of the latest track segment
            const latestSegment = track[track.length - 1];
            const endX = latestSegment.end.x;
            const endZ = latestSegment.end.z;
            
            // Create all ground tiles in a larger area around the latest track segment
            // This ensures more complete coverage without gaps
            const baseTileX = Math.floor(endX / groundTileSize) * groundTileSize;
            const baseTileZ = Math.floor(endZ / groundTileSize) * groundTileSize;
            
            // Get direction of travel to determine "right" and "left" sides
            let dirX = 0, dirZ = 1; // Default direction (forward)
            
            if (track.length >= 2) {
                const prevSegment = track[track.length - 2];
                dirX = latestSegment.end.x - prevSegment.end.x;
                dirZ = latestSegment.end.z - prevSegment.end.z;
                // Normalize
                const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
                if (dirLength > 0) {
                    dirX /= dirLength;
                    dirZ /= dirLength;
                }
            }
            
            // Calculate right side vector (perpendicular to direction)
            const rightX = -dirZ;
            const rightZ = dirX;
            
            // Create a larger grid of tiles around the track point
            // Extended more on the right side and ahead
            for (let xOffset = -2; xOffset <= 3; xOffset++) {
                for (let zOffset = -2; zOffset <= 3; zOffset++) {
                    const tileX = baseTileX + xOffset * groundTileSize + groundTileSize / 2;
                    const tileZ = baseTileZ + zOffset * groundTileSize + groundTileSize / 2;
                    
                    // Use a more reliable way to check if a tile exists at this position
                    let tileExists = false;
                    for (let i = 0; i < groundTiles.length; i++) {
                        const tile = groundTiles[i];
                        // Use a very small epsilon for floating point comparison
                        if (Math.abs(tile.x - tileX) < 0.1 && Math.abs(tile.z - tileZ) < 0.1) {
                            tileExists = true;
                            break;
                        }
                    }
                    
                    if (!tileExists) {
                        createGroundTile(tileX, tileZ);
                    }
                }
            }
            
            // Create extra tiles specifically on the right side relative to the car's direction
            // This ensures better coverage on the problematic side
            for (let i = 1; i <= 3; i++) {
                const extraRightX = baseTileX + (rightX * i * groundTileSize) + groundTileSize / 2;
                const extraRightZ = baseTileZ + (rightZ * i * groundTileSize) + groundTileSize / 2;
                
                let rightTileExists = false;
                for (let j = 0; j < groundTiles.length; j++) {
                    const tile = groundTiles[j];
                    if (Math.abs(tile.x - extraRightX) < 0.1 && Math.abs(tile.z - extraRightZ) < 0.1) {
                        rightTileExists = true;
                        break;
                    }
                }
                
                if (!rightTileExists) {
                    createGroundTile(extraRightX, extraRightZ);
                    
                    // Add surrounding tiles for the extra right tiles too
                    for (let xOffset = -1; xOffset <= 1; xOffset++) {
                        for (let zOffset = -1; zOffset <= 1; zOffset++) {
                            if (xOffset === 0 && zOffset === 0) continue; // Skip center we just created
                            
                            const surroundX = extraRightX + xOffset * groundTileSize;
                            const surroundZ = extraRightZ + zOffset * groundTileSize;
                            
                            let surroundExists = false;
                            for (let k = 0; k < groundTiles.length; k++) {
                                const tile = groundTiles[k];
                                if (Math.abs(tile.x - surroundX) < 0.1 && Math.abs(tile.z - surroundZ) < 0.1) {
                                    surroundExists = true;
                                    break;
                                }
                            }
                            
                            if (!surroundExists) {
                                createGroundTile(surroundX, surroundZ);
                            }
                        }
                    }
                }
            }
            
            // Also create tiles at the midpoint between current segment and previous segment
            // This helps ensure continuous coverage along the track
            if (track.length > 1) {
                const prevSegment = track[track.length - 2];
                const midX = (prevSegment.end.x + latestSegment.end.x) / 2;
                const midZ = (prevSegment.end.z + latestSegment.end.z) / 2;
                
                const midTileX = Math.floor(midX / groundTileSize) * groundTileSize + groundTileSize / 2;
                const midTileZ = Math.floor(midZ / groundTileSize) * groundTileSize + groundTileSize / 2;
                
                // Check if a tile exists at the midpoint
                let midTileExists = false;
                for (let i = 0; i < groundTiles.length; i++) {
                    const tile = groundTiles[i];
                    if (Math.abs(tile.x - midTileX) < 0.1 && Math.abs(tile.z - midTileZ) < 0.1) {
                        midTileExists = true;
                        break;
                    }
                }
                
                if (!midTileExists) {
                    createGroundTile(midTileX, midTileZ);
                    
                    // Also create tiles around the midpoint for better coverage
                    for (let xOffset = -2; xOffset <= 2; xOffset++) {
                        for (let zOffset = -2; zOffset <= 2; zOffset++) {
                            if (xOffset === 0 && zOffset === 0) continue; // Skip the center tile we just created
                            
                            const tileX = midTileX + xOffset * groundTileSize;
                            const tileZ = midTileZ + zOffset * groundTileSize;
                            
                            let surroundTileExists = false;
                            for (let i = 0; i < groundTiles.length; i++) {
                                const tile = groundTiles[i];
                                if (Math.abs(tile.x - tileX) < 0.1 && Math.abs(tile.z - tileZ) < 0.1) {
                                    surroundTileExists = true;
                                    break;
                                }
                            }
                            
                            if (!surroundTileExists) {
                                createGroundTile(tileX, tileZ);
                            }
                        }
                    }
                }
            }
            
            // Generate extra ground tiles based on the car's position too
            // This ensures we have ground coverage where the player actually is
            if (car) {
                const carX = car.position.x;
                const carZ = car.position.z;
                
                const carBaseTileX = Math.floor(carX / groundTileSize) * groundTileSize;
                const carBaseTileZ = Math.floor(carZ / groundTileSize) * groundTileSize;
                
                // Create tiles in a grid around the car
                for (let xOffset = -2; xOffset <= 2; xOffset++) {
                    for (let zOffset = -2; zOffset <= 2; zOffset++) {
                        const tileX = carBaseTileX + xOffset * groundTileSize + groundTileSize / 2;
                        const tileZ = carBaseTileZ + zOffset * groundTileSize + groundTileSize / 2;
                        
                        let tileExists = false;
                        for (let i = 0; i < groundTiles.length; i++) {
                            const tile = groundTiles[i];
                            if (Math.abs(tile.x - tileX) < 0.1 && Math.abs(tile.z - tileZ) < 0.1) {
                                tileExists = true;
                                break;
                            }
                        }
                        
                        if (!tileExists) {
                            createGroundTile(tileX, tileZ);
                        }
                    }
                }
            }
        }
        
        function addObstacle(segment) {
            const obsGeometry = new THREE.BoxGeometry(2, 2, 2);
            const obsMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const obstacle = new THREE.Mesh(obsGeometry, obsMaterial);
            
            // Calculate track direction
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            
            // Normalize direction
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Calculate position along track (between 10-90%)
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Calculate lateral offset (stay within track width)
            const lateralOffset = (Math.random() - 0.5) * trackWidth * 0.6;
            
            // Calculate final position
            const posX = segment.start.x + dirX * alongTrack + perpX * lateralOffset;
            const posZ = segment.start.z + dirZ * alongTrack + perpZ * lateralOffset;
            
            obstacle.position.set(posX, 1, posZ);
            obstacle.castShadow = true;
            obstacle.receiveShadow = true;
            scene.add(obstacle);
            
            obstacles.push({
                mesh: obstacle,
                segment: track.length - 1,
                collided: false
            });
        }
        
        function addPowerUp(segment) {
            const types = ['speed', 'shield', 'nitro'];
            const type = types[Math.floor(Math.random() * types.length)];
            
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            let material;
            
            if (type === 'speed') {
                material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            } else if (type === 'shield') {
                material = new THREE.MeshPhongMaterial({ color: 0x0000ff });
            } else {
                material = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            }
            
            const powerUp = new THREE.Mesh(geometry, material);
            
            // Calculate track direction
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            
            // Normalize direction
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Calculate position along track (between 10-90%)
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Calculate lateral offset (stay within track width)
            const lateralOffset = (Math.random() - 0.5) * trackWidth * 0.6;
            
            // Calculate final position
            const posX = segment.start.x + dirX * alongTrack + perpX * lateralOffset;
            const posZ = segment.start.z + dirZ * alongTrack + perpZ * lateralOffset;
            
            powerUp.position.set(posX, 1, posZ);
            scene.add(powerUp);
            
            // Add some rotation animation
            powerUp.userData.rotationSpeed = 0.03;
            powerUp.userData.floatSpeed = 0.02;
            powerUp.userData.floatHeight = 0.5;
            powerUp.userData.baseY = 1;
            powerUp.userData.time = Math.random() * Math.PI * 2;
            
            powerUps.push({
                mesh: powerUp,
                type: type,
                segment: track.length - 1,
                collected: false
            });
        }
        
        function updateCar(delta) {
            // Handle inputs
            let moveForward = keys['w'] || keys['arrowup'];
            let moveBackward = keys['s'] || keys['arrowdown'];
            let turnLeft = keys['a'] || keys['arrowleft'];
            let turnRight = keys['d'] || keys['arrowright'];
            let nitro = keys[' '];
            
            // Update speed based on inputs
            if (moveForward) {
                speed += acceleration * delta;
            } else if (moveBackward) {
                speed -= acceleration * 1.5 * delta;
            } else {
                // Apply friction to slow down
                speed *= 0.98;
            }
            
            // Apply active power-up effects
            if (activePowerUp === 'speed') {
                speed = Math.min(speed, maxSpeed * 1.2);
            } else if (activePowerUp === 'nitro' && nitro) {
                speed += acceleration * 3 * delta;
                activePowerUp = null;
                powerUpTimer = 0;
                document.getElementById('powerup').textContent = '';
            } else {
                speed = Math.min(speed, maxSpeed);
            }
            
            speed = Math.max(speed, -maxSpeed / 2); // Limit reverse speed
            speed = Math.min(speed, maxSpeed * 1.5); // Hard cap to prevent insane speeds
            
            // Update steering based on inputs
            let steeringAmount = 0;
            
            // Handle keyboard steering
            if (turnLeft) steeringAmount = steering * delta;
            if (turnRight) steeringAmount = -steering * delta;
            
            // Handle joystick steering for mobile
            if (isMobileDevice && joystickInput !== 0) {
                // Apply a small deadzone to prevent tiny movements
                if (Math.abs(joystickInput) > 0.1) {
                    // Invert joystick input to match the game's steering direction
                    steeringAmount = -joystickInput * steering * delta * 1.5; // Slightly increased sensitivity
                }
            }
            
            // Improved steering - reduce steering at high speeds and when not moving
            const speedFactor = Math.min(1.0, Math.abs(speed) / (maxSpeed * 0.5));
            const steeringFactor = Math.abs(speed) < 5 ? 0.2 : 1.0;
            
            // Apply steering with improved control
            car.rotation.y += steeringAmount * speedFactor * steeringFactor;
            
            // Move car forward
            const movement = speed * delta;
            car.position.x += Math.sin(car.rotation.y) * movement;
            car.position.z += Math.cos(car.rotation.y) * movement;
            
            // Update camera position
            updateCamera();
            
            // Update score based on distance traveled
            score += Math.abs(movement);
            
            // Only update DOM once per 5 frames for better performance
            if (frameCount % 5 === 0) {
                document.getElementById('score').textContent = `Distance: ${Math.floor(score)}m`;
                document.getElementById('speed').textContent = `Speed: ${Math.floor(speed)} km/h`;
            }
        }
        
        function updateCamera() {
            // Position camera relative to car
            const idealOffset = cameraOffset.clone();
            idealOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), car.rotation.y);
            
            camera.position.copy(car.position).add(idealOffset);
            camera.lookAt(car.position);
        }
        
        function checkCollisions() {
            // Check for obstacle collisions - only check obstacles near the car
            // Calculate car position once
            const carPos = new THREE.Vector3(car.position.x, 0, car.position.z);
            const carX = car.position.x;
            const carZ = car.position.z;
            
            // Reuse this variable for efficiency
            let dx, dz, distanceSquared;
            
            // Track if we've collided with any obstacle
            let hasCollided = false;
            
            // Optimize obstacle collision checks
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                // Skip collision checks for objects far from the car
                if (obstacle.collided) {
                    continue;
                }
                
                // Find the segment index for this obstacle
                let obstacleSegmentIndex = -1;
                for (let j = 0; j < track.length; j++) {
                    if (track[j].segment === obstacle.segment) {
                        obstacleSegmentIndex = j;
                        break;
                    }
                }
                
                // Skip if the obstacle's segment is too far from current segment
                if (obstacleSegmentIndex === -1 || Math.abs(obstacleSegmentIndex - currentSegment) > 5) {
                    continue; 
                }
                
                // Use fast squared distance check (avoid expensive sqrt)
                dx = carX - obstacle.mesh.position.x;
                dz = carZ - obstacle.mesh.position.z;
                distanceSquared = dx * dx + dz * dz;
                
                if (distanceSquared < 6.25) { // 2.5 * 2.5 = 6.25
                    if (activePowerUp !== 'shield') {
                        hasCollided = true;
                        break; // Exit early once we know we've collided
                    } else {
                        // Remove obstacle if we have a shield
                        scene.remove(obstacle.mesh);
                        obstacle.collided = true;
                    }
                }
            }
            
            if (hasCollided) {
                gameOver();
                return;
            }
            
            // Use a similar approach for power-ups with early return
            for (let i = 0; i < powerUps.length; i++) {
                const powerUp = powerUps[i];
                
                // Skip checks for objects that are far away or already collected
                if (powerUp.collected) {
                    continue;
                }
                
                // Find the segment index for this power-up
                let powerUpSegmentIndex = -1;
                for (let j = 0; j < track.length; j++) {
                    if (track[j].segment === powerUp.segment) {
                        powerUpSegmentIndex = j;
                        break;
                    }
                }
                
                // Skip if the power-up's segment is too far from current segment
                if (powerUpSegmentIndex === -1 || Math.abs(powerUpSegmentIndex - currentSegment) > 5) {
                    continue;
                }
                
                // Use fast squared distance check
                dx = carX - powerUp.mesh.position.x;
                dz = carZ - powerUp.mesh.position.z;
                distanceSquared = dx * dx + dz * dz;
                
                if (distanceSquared < 6.25) { // 2.5 * 2.5 = 6.25
                    collectPowerUp(powerUp);
                }
            }
            
            // First check transitions between segments for smoother handling
            let onTrack = checkSegmentTransitions(carPos);
            
            // If not at a transition, check individual segments
            if (!onTrack) {
                // Calculate search bounds to limit track segments we check
                const startSegment = Math.max(0, currentSegment - 2);
                const endSegment = Math.min(track.length, currentSegment + 3);
                
                // Check if car is on any track segment
                for (let i = startSegment; i < endSegment; i++) {
                    const segment = track[i];
                    
                    // For straight segments, calculate projection onto the line
                    const start = new THREE.Vector3(segment.start.x, 0, segment.start.z);
                    const end = new THREE.Vector3(segment.end.x, 0, segment.end.z);
                    const line = new THREE.Line3(start, end);
                    
                    const closestPoint = new THREE.Vector3();
                    line.closestPointToPoint(carPos, true, closestPoint);
                    
                    const distance = carPos.distanceTo(closestPoint);
                    
                    if (distance < trackWidth * 0.95) { // Very forgiving track width detection
                        onTrack = true;
                        
                        // If we're on a new segment, potentially generate more track
                        if (i > currentSegment) {
                            currentSegment = i;
                            
                            // Generate new track segments when we're approaching the end
                            // Now use the array index instead of the logical segment number
                            if (track.length - i < 5) {
                                // Add multiple segments at once to ensure we're always generating ahead
                                for (let j = 0; j < 5; j++) {  // Increased from 3 to 5 segments for better lookahead
                                    addTrackSegment();
                                }
                                
                                // Always ensure we have enough segments ahead
                                if (track.length - currentSegment < 10) {
                                    for (let j = 0; j < 3; j++) {
                                        addTrackSegment();
                                    }
                                }
                            }
                        }
                        
                        break;
                    }
                }
            }
            
            if (!onTrack && activePowerUp !== 'shield') {
                gameOver();
            }
        }
        
        function collectPowerUp(powerUp) {
            scene.remove(powerUp.mesh);
            powerUp.collected = true;
            
            activePowerUp = powerUp.type;
            
            if (powerUp.type === 'speed') {
                powerUpTimer = 5; // 5 seconds
                document.getElementById('powerup').textContent = 'Speed Boost Active!';
            } else if (powerUp.type === 'shield') {
                powerUpTimer = 10; // 10 seconds
                document.getElementById('powerup').textContent = 'Shield Active!';
                
                // Add visual shield effect - optimized with lower geometry detail
                const shieldGeometry = new THREE.SphereGeometry(3, 8, 8); // Reduced segments for better performance
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0088ff,
                    transparent: true,
                    opacity: 0.3
                });
                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                shield.name = 'shield';
                car.add(shield);
                
                // Removed the setTimeout - we'll handle shield removal in updatePowerUps instead
            } else if (powerUp.type === 'nitro') {
                document.getElementById('powerup').textContent = 'Nitro Ready! Press SPACE';
            }
        }
        
        function updatePowerUps(delta) {
            // Update power-up timer and handle expiration
            if (activePowerUp && powerUpTimer > 0) {
                powerUpTimer -= delta;
                
                if (powerUpTimer <= 0) {
                    // Handle power-up expiration
                    if (activePowerUp === 'shield') {
                        // Remove shield visual - more efficient than using setTimeout
                        const shield = car.getObjectByName('shield');
                        if (shield) {
                            car.remove(shield);
                            // Help garbage collection
                            shield.geometry.dispose();
                            shield.material.dispose();
                        }
                    }
                    
                    activePowerUp = null;
                    document.getElementById('powerup').textContent = '';
                }
            }

            // Update power-up visuals
            for (let i = 0; i < powerUps.length; i++) {
                const powerUp = powerUps[i];
                if (!powerUp.collected) {
                    // Rotate power-up
                    powerUp.mesh.rotation.y += powerUp.mesh.userData.rotationSpeed;
                    
                    // Float up and down
                    powerUp.mesh.userData.time += powerUp.mesh.userData.floatSpeed;
                    powerUp.mesh.position.y = powerUp.mesh.userData.baseY + 
                        Math.sin(powerUp.mesh.userData.time) * powerUp.mesh.userData.floatHeight;
                }
            }
        }
        
        function checkSegmentTransitions(carPos) {
            // This function checks if the car is at a segment transition
            // (between two segments) to avoid losing track detection between segments
            
            // Only check if we have at least 2 segments and not on the first segment
            if (track.length < 2 || currentSegment === 0) {
                return false;
            }
            
            // Get current and previous segments
            const currentSeg = track[currentSegment];
            const prevSeg = track[Math.max(0, currentSegment - 1)];
            
            // Check if we're near the transition between previous and current segment
            const transitionPoint = new THREE.Vector3(currentSeg.start.x, 0, currentSeg.start.z);
            const distToTransition = carPos.distanceTo(transitionPoint);
            
            // If we're near the transition point, check if we're on either segment
            if (distToTransition < trackWidth * 1.5) {
                // Check if on previous segment
                const prevStart = new THREE.Vector3(prevSeg.start.x, 0, prevSeg.start.z);
                const prevEnd = new THREE.Vector3(prevSeg.end.x, 0, prevSeg.end.z);
                const prevLine = new THREE.Line3(prevStart, prevEnd);
                
                const prevClosest = new THREE.Vector3();
                prevLine.closestPointToPoint(carPos, true, prevClosest);
                const prevDistance = carPos.distanceTo(prevClosest);
                
                if (prevDistance < trackWidth) {
                    return true;
                }
                
                // Check if on current segment
                const currStart = new THREE.Vector3(currentSeg.start.x, 0, currentSeg.start.z);
                const currEnd = new THREE.Vector3(currentSeg.end.x, 0, currentSeg.end.z);
                const currLine = new THREE.Line3(currStart, currEnd);
                
                const currClosest = new THREE.Vector3();
                currLine.closestPointToPoint(carPos, true, currClosest);
                const currDistance = carPos.distanceTo(currClosest);
                
                if (currDistance < trackWidth) {
                    return true;
                }
            }
            
            // Also check next segment if we're at the end of current segment
            if (currentSegment < track.length - 1) {
                const nextSeg = track[currentSegment + 1];
                const currentEnd = new THREE.Vector3(currentSeg.end.x, 0, currentSeg.end.z);
                const distToEnd = carPos.distanceTo(currentEnd);
                
                if (distToEnd < trackWidth * 1.5) {
                    // Check if on next segment
                    const nextStart = new THREE.Vector3(nextSeg.start.x, 0, nextSeg.start.z);
                    const nextEnd = new THREE.Vector3(nextSeg.end.x, 0, nextSeg.end.z);
                    const nextLine = new THREE.Line3(nextStart, nextEnd);
                    
                    const nextClosest = new THREE.Vector3();
                    nextLine.closestPointToPoint(carPos, true, nextClosest);
                    const nextDistance = carPos.distanceTo(nextClosest);
                    
                    if (nextDistance < trackWidth) {
                        // We're on the next segment, update currentSegment
                        currentSegment++;
                        
                        // Ensure we're generating more track if needed
                        if (track.length - currentSegment < 10) {
                            for (let j = 0; j < 3; j++) {
                                addTrackSegment();
                            }
                        }
                        
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        function gameOver() {
            gameActive = false;
            
            // Update high score
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('highScore', highScore);
            }
            
            // Show game over screen
            document.getElementById('finalScore').textContent = `Distance: ${Math.floor(score)}m`;
            document.getElementById('highScore').textContent = `High Score: ${Math.floor(highScore)}m`;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function resetGame() {
            // Remove all objects
            while(scene && scene.children.length > 0){ 
                scene.remove(scene.children[0]); 
            }
            
            // Reset variables
            track = [];
            obstacles = [];
            powerUps = [];
            groundTiles = []; // Also reset ground tiles
            score = 0;
            speed = 0;
            activePowerUp = null;
            powerUpTimer = 0;
            currentSegment = 0;
            
            // Clean up any active shield visual effects
            if (car) {
                const shield = car.getObjectByName('shield');
                if (shield) car.remove(shield);
            }
            
            // Recreate scene without creating a new renderer
            init();
        }
        
        // Frame counting for throttling operations
        let frameCount = 0;
        let lastFrameTime = 0;
        let frameTimeHistory = [16, 16, 16, 16, 16]; // Initialize with reasonable default
        
        function animate(timestamp) {
            requestAnimationFrame(animate);
            
            // Calculate actual frame time for adaptive performance
            const frameTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            
            // Update frame time history (moving average)
            frameTimeHistory.shift();
            frameTimeHistory.push(Math.min(100, frameTime)); // Cap at 100ms to avoid spikes
            
            // Calculate average frame time
            const avgFrameTime = frameTimeHistory.reduce((a, b) => a + b, 0) / frameTimeHistory.length;
            
            // Adaptive quality based on performance
            const isLagging = avgFrameTime > 30; // If average frame time is > 30ms we're not hitting 30fps
            
            // Measure delta time for animation
            const delta = Math.min(0.1, clock.getDelta()); // Cap delta to prevent large jumps
            frameCount++;
            
            if (gameActive) {
                updateCar(delta);
                
                // Throttle expensive operations when lagging
                const collisionInterval = isLagging ? 3 : 2;
                const environmentInterval = isLagging ? 5 : 3;
                
                // Run collision checks every few frames
                if (frameCount % collisionInterval === 0) {
                    checkCollisions();
                }
                
                updatePowerUps(delta);
                
                // Throttle environment updates - only update every few frames
                if (frameCount % environmentInterval === 0) {
                    updateEnvironment(delta);
                }
            }
            
            renderer.render(scene, camera);
        }
        
        function updateEnvironment(delta) {
            // Update environmental objects (lights, animations, etc.)
            // Only update visible objects (optimization)
            const visibleDistance = 100; // Only update objects within this distance
            
            // Cache car position for multiple checks
            const carX = car.position.x;
            const carZ = car.position.z;
            
            // Only update a subset of objects each frame to spread the load
            const objectsPerFrame = Math.min(environmentObjects.length, 10);
            const startIdx = frameCount % Math.max(1, environmentObjects.length - objectsPerFrame);
            const endIdx = Math.min(startIdx + objectsPerFrame, environmentObjects.length);
            
            for (let i = startIdx; i < endIdx; i++) {
                const object = environmentObjects[i];
                
                // Skip updates for distant objects
                if (object.segment !== undefined && Math.abs(object.segment - currentSegment) > 10) {
                    continue;
                }
                
                if (object.type === 'pulsingLight' && object.mesh) {
                    // Animate pulsing lights
                    object.mesh.userData.phase += delta * object.mesh.userData.speed;
                    object.mesh.intensity = object.mesh.userData.initialIntensity + 
                                           Math.sin(object.mesh.userData.phase) * 0.3;
                } else if (object.type === 'spotlight' && object.mesh && car) {
                    // Update spotlight to follow car
                    object.mesh.position.copy(car.position);
                    object.mesh.position.y += 10;
                    object.mesh.position.z -= 5;
                }
            }
            
            // Clean up environment objects that are too far behind
            // This operation is expensive, so only do it every 5 seconds (optimization)
            if (!environmentObjects.lastCleanupTime || Date.now() - environmentObjects.lastCleanupTime > 5000) {
                environmentObjects = environmentObjects.filter(object => {
                    // If this object is not segment-related or doesn't have a segment number, keep it
                    if (object.segment === undefined || !object.mesh) {
                        return true;
                    }
                    
                    // Find the index of the segment this object belongs to
                    let segmentIndex = -1;
                    for (let i = 0; i < track.length; i++) {
                        if (track[i].segment === object.segment) {
                            segmentIndex = i;
                            break;
                        }
                    }
                    
                    // If the segment doesn't exist anymore or is too far behind, remove the object
                    if (segmentIndex === -1 || segmentIndex < currentSegment - 20) {
                        scene.remove(object.mesh);
                        return false;
                    }
                    return true;
                });
                environmentObjects.lastCleanupTime = Date.now();
            }
            
            // Check if we need to clean up track segments
            // This operation is expensive, so only do it every 5 seconds
            if (!track.lastCleanupTime || Date.now() - track.lastCleanupTime > 5000) {
                // Clean up obsolete track segments, but leave a generous buffer
                // Keep at least 20 segments behind the player to allow for backtracking
                // and 30 segments in total to ensure plenty of track exists
                const segmentsToKeep = Math.max(30, currentSegment + 20);
                
                if (track.length > segmentsToKeep) {
                    // Store current segment's logical ID before cleanup
                    const currentSegmentId = track[currentSegment].segment;
                    
                    // Keep removing segments from the beginning as long as we have enough buffer segments
                    while (track.length > segmentsToKeep) {
                        const oldSegment = track.shift();
                        if (oldSegment.mesh) {
                            scene.remove(oldSegment.mesh);
                            
                            // Return track material to object pool
                            if (oldSegment.material) {
                                objectPool.returnTrackMaterial(oldSegment.material);
                            }
                            
                            // Dispose of geometry
                            if (oldSegment.mesh.geometry) {
                                oldSegment.mesh.geometry.dispose();
                            }
                        }
                    }
                    
                    // Find the new array index of the segment we were on
                    for (let i = 0; i < track.length; i++) {
                        if (track[i].segment === currentSegmentId) {
                            currentSegment = i;
                            break;
                        }
                    }
                    
                    // Update the arrayIndex property of all remaining segments
                    for (let i = 0; i < track.length; i++) {
                        track[i].arrayIndex = i;
                    }
                }
                track.lastCleanupTime = Date.now();
            }
            
            // Clean up ground tiles that are too far behind
            // This operation is expensive, so only do it every 5 seconds
            if (!groundTiles.lastCleanupTime || Date.now() - groundTiles.lastCleanupTime > 5000) {
                groundTiles = groundTiles.filter(tile => {
                    // Calculate distance to car (use squared distance for efficiency)
                    const dx = tile.x - carX;
                    const dz = tile.z - carZ;
                    const distanceSquared = dx * dx + dz * dz;
                    
                    // Remove tiles that are too far away
                    if (distanceSquared > 700 * 700) {
                        scene.remove(tile.mesh);
                        
                        // Return texture to object pool for reuse
                        if (tile.texture) {
                            objectPool.returnGroundTexture(tile.texture);
                        }
                        
                        // Dispose of materials and geometry
                        if (tile.mesh.material) {
                            if (Array.isArray(tile.mesh.material)) {
                                tile.mesh.material.forEach(m => m.dispose());
                            } else {
                                tile.mesh.material.dispose();
                            }
                        }
                        
                        if (tile.mesh.geometry) {
                            tile.mesh.geometry.dispose();
                        }
                        
                        return false;
                    }
                    return true;
                });
                groundTiles.lastCleanupTime = Date.now();
            }
        }
        
        // Add the missing addEnvironmentObject function
        function addEnvironmentObject(segment, type) {
            // Determine object based on type parameter
            let geometry, material, mesh;
            let scale = 1;
            let height = 0;
            let segmentOffset = 0;
            
            // Calculate track direction for positioning
            const dirX = segment.end.x - segment.start.x;
            const dirZ = segment.end.z - segment.start.z;
            const dirLength = Math.sqrt(dirX * dirX + dirZ * dirZ);
            const normDirX = dirX / dirLength;
            const normDirZ = dirZ / dirLength;
            
            // Calculate perpendicular direction (normal to track)
            const perpX = -normDirZ;
            const perpZ = normDirX;
            
            // Randomize position along track
            const alongTrack = Math.random() * 0.8 + 0.1;
            
            // Create different objects based on type
            if (type === 'building') {
                // Create a cyberpunk-style building
                geometry = new THREE.BoxGeometry(6 + Math.random() * 6, 10 + Math.random() * 20, 6 + Math.random() * 6);
                
                // Use one of the neon colors for emissive
                const neonColors = themeSettings[theme].neonColors;
                const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                
                material = new THREE.MeshPhongMaterial({
                    color: 0x111111,
                    emissive: neonColor,
                    emissiveIntensity: 0.3
                });
                
                mesh = new THREE.Mesh(geometry, material);
                height = geometry.parameters.height / 2;
                scale = 1;
                
                // Place buildings further away from track
                segmentOffset = (10 + Math.random() * 15) * (Math.random() > 0.5 ? 1 : -1);
            } else if (type === 'tree') {
                // Create a cyberpunk-style "tree" (more like a tech pillar)
                const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.5, 5, 6);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                // Create a glowing top
                const topGeometry = new THREE.SphereGeometry(2, 8, 8);
                
                // Use one of the neon colors
                const neonColors = themeSettings[theme].neonColors;
                const neonColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                
                const topMaterial = new THREE.MeshPhongMaterial({
                    color: 0x222222,
                    emissive: neonColor,
                    emissiveIntensity: 0.6
                });
                
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = 3;
                
                // Group the parts
                mesh = new THREE.Group();
                mesh.add(trunk);
                mesh.add(top);
                
                height = 0; // The trunk already positions itself correctly
                scale = 0.8 + Math.random() * 0.4;
                
                // Place trees not too far from track
                segmentOffset = (6 + Math.random() * 10) * (Math.random() > 0.5 ? 1 : -1);
            } else if (type === 'debris') {
                // Create some cyberpunk debris/junk
                if (Math.random() > 0.5) {
                    // Create a pile of boxes
                    mesh = new THREE.Group();
                    
                    for (let i = 0; i < 3 + Math.floor(Math.random() * 3); i++) {
                        const boxSize = 0.5 + Math.random() * 1.5;
                        const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
                        
                        const boxMaterial = new THREE.MeshPhongMaterial({
                            color: 0x333333
                        });
                        
                        const box = new THREE.Mesh(boxGeometry, boxMaterial);
                        box.position.set(
                            (Math.random() - 0.5) * 2,
                            boxSize / 2 + Math.random() * 0.5,
                            (Math.random() - 0.5) * 2
                        );
                        
                        box.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                        );
                        
                        mesh.add(box);
                    }
                } else {
                    // Create a damaged vehicle or tech item
                    geometry = new THREE.BoxGeometry(2 + Math.random(), 1 + Math.random(), 3 + Math.random());
                    material = new THREE.MeshPhongMaterial({ 
                        color: 0x555555,
                        emissive: 0xff0000,
                        emissiveIntensity: Math.random() * 0.3
                    });
                    mesh = new THREE.Mesh(geometry, material);
                    height = geometry.parameters.height / 2;
                }
                
                scale = 0.7 + Math.random() * 0.6;
                
                // Place debris closer to track
                segmentOffset = (3 + Math.random() * 7) * (Math.random() > 0.5 ? 1 : -1);
            }
            
            if (mesh) {
                // Calculate final position
                const posX = segment.start.x + dirX * alongTrack + perpX * segmentOffset;
                const posZ = segment.start.z + dirZ * alongTrack + perpZ * segmentOffset;
                
                mesh.position.set(posX, height, posZ);
                mesh.scale.set(scale, scale, scale);
                
                // Add subtle random rotation
                mesh.rotation.y = Math.random() * Math.PI * 2;
                
                // Enable shadows
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Apply material settings to all child meshes in case of groups
                mesh.traverse(function(child) {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(mesh);
                
                // Add to environment objects array with segment reference
                environmentObjects.push({
                    mesh: mesh,
                    type: type,
                    segment: track.length - 1  // Current segment being built
                });
            }
        }
        
        // Add the missing onWindowResize function
        function onWindowResize() {
            // Update camera aspect ratio
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            
            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Initialize the game
        init();
        
        // Start animation with timestamp
        requestAnimationFrame(animate);
        
        // Create track material with cyberpunk style
        function createTrackMaterial() {
            // Create track texture with lane markings - cyberpunk style
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const context = canvas.getContext('2d');
            
            // Fill with road color (dark for cyberpunk but not too dark)
            context.fillStyle = '#111111';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add asphalt texture
            const size = 16; // Increase size for better performance
            const noise = 0.1;
            context.fillStyle = '#0a0a0a';
            
            // Use a more efficient approach to drawing noise
            for (let x = 0; x < canvas.width; x += size * 2) {
                for (let y = 0; y < canvas.height; y += size * 2) {
                    if (Math.random() < 0.3) {
                        context.globalAlpha = 0.05 + Math.random() * noise;
                        context.fillRect(x, y, size, size);
                    }
                }
            }
            
            context.globalAlpha = 1.0;
            
            // Add cyberpunk grid pattern
            context.strokeStyle = '#00ffff';
            context.lineWidth = 1;
            context.setLineDash([1, 8]);
            
            // Horizontal grid lines - draw fewer lines for better performance
            for (let y = 0; y < canvas.height; y += 64) { // Increased spacing
                context.beginPath();
                context.moveTo(0, y);
                context.lineTo(canvas.width, y);
                context.stroke();
            }
            
            // Draw road edges - neon style
            context.strokeStyle = '#ff00ff'; // Magenta neon
            context.lineWidth = 8;
            context.setLineDash([]);
            
            // Left edge
            context.beginPath();
            context.moveTo(canvas.width * 0.1, 0);
            context.lineTo(canvas.width * 0.1, canvas.height);
            context.stroke();
            
            // Right edge
            context.beginPath();
            context.moveTo(canvas.width * 0.9, 0);
            context.lineTo(canvas.width * 0.9, canvas.height);
            context.stroke();
            
            // Draw center dashed line - neon cyan
            context.strokeStyle = '#00ffff';
            context.lineWidth = 6;
            context.setLineDash([20, 20]);
            context.beginPath();
            context.moveTo(canvas.width / 2, 0);
            context.lineTo(canvas.width / 2, canvas.height);
            context.stroke();
            
            // Create texture
            const texture = new THREE.CanvasTexture(canvas);
            texture.repeat.set(1, 5);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            // Create material with brighter emissive for neon glow effect
            // And with depth write enabled to avoid z-fighting
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.DoubleSide,
                emissive: 0x330066,
                emissiveIntensity: 0.5, // Increased emissive intensity
                depthWrite: true, // Enable depth write
                polygonOffset: true, // Enable polygon offset
                polygonOffsetFactor: -1, // Apply a small offset to fix z-fighting
                polygonOffsetUnits: -1
            });
            
            return material;
        }
        
        // Set up UI button event listeners
        document.getElementById('startGame').addEventListener('click', function() {
            document.getElementById('menu').style.display = 'none';
            gameActive = true;
        });
        
        document.getElementById('playAgain').addEventListener('click', function() {
            document.getElementById('gameOver').style.display = 'none';
            resetGame();
            gameActive = true;
        });
        
        document.getElementById('mainMenu').addEventListener('click', function() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('menu').style.display = 'block';
            resetGame();
        });
        
        document.getElementById('shareScore').addEventListener('click', function() {
            const scoreText = `I reached ${Math.floor(score)}m in Endless Drive!`;
            
            // Try to use the Web Share API if available
            if (navigator.share) {
                navigator.share({
                    title: 'Endless Drive Score',
                    text: scoreText,
                }).catch(error => {
                    console.log('Error sharing:', error);
                    // Fallback to copying to clipboard
                    copyToClipboard(scoreText);
                });
            } else {
                // Fallback to copying to clipboard
                copyToClipboard(scoreText);
            }
        });
        
        // Helper function for copying to clipboard
        function copyToClipboard(text) {
            const tempInput = document.createElement('input');
            tempInput.value = text;
            document.body.appendChild(tempInput);
            tempInput.select();
            document.execCommand('copy');
            document.body.removeChild(tempInput);
            
            alert('Score copied to clipboard: ' + text);
        }
        
        // Function to detect if device has touch capability
        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0));
        }
        
        // Set up mobile controls with joystick
        function setupMobileControls() {
            const mobileControls = document.getElementById('mobileControls');
            
            // Only show mobile controls on touch devices
            isMobileDevice = isTouchDevice();
            if (isMobileDevice) {
                mobileControls.style.display = 'block';
                
                // Initialize joystick
                const joystickOptions = {
                    zone: document.getElementById('joystickZone'),
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    size: window.innerHeight > window.innerWidth ? 120 : 150, // Larger in landscape mode
                    color: 'rgba(255, 0, 255, 0.5)',
                    lockX: false,
                    lockY: false // Allow movement in all directions
                };
                
                let joystick = nipplejs.create(joystickOptions);
                
                // Handle orientation changes to update joystick size
                window.addEventListener('orientationchange', function() {
                    // Destroy and recreate joystick with new size after orientation change
                    setTimeout(function() {
                        joystick.destroy();
                        const newSize = window.innerHeight > window.innerWidth ? 120 : 150;
                        const newJoystickOptions = {
                            zone: document.getElementById('joystickZone'),
                            mode: 'static',
                            position: { left: '50%', top: '50%' },
                            size: newSize,
                            color: 'rgba(255, 0, 255, 0.5)',
                            lockX: false,
                            lockY: false
                        };
                        // Update the joystick variable with the new instance
                        joystick = nipplejs.create(newJoystickOptions);
                        
                        // Reattach event handlers
                        joystick.on('move', function(evt, data) {
                            joystickInput = data.vector.x;
                            
                            // Apply a small deadzone to prevent tiny movements
                            if (Math.abs(joystickInput) < 0.1) {
                                joystickInput = 0;
                            }
                            
                            keys['arrowleft'] = false;
                            keys['arrowright'] = false;
                        });
                        
                        joystick.on('end', function() {
                            joystickInput = 0;
                        });
                    }, 300); // Small delay to ensure DOM has updated
                });
                
                // Joystick event handlers
                joystick.on('move', function(evt, data) {
                    // Calculate steering input from joystick position
                    // Make sure we're using the correct vector component for steering
                    // data.vector.x is between -1 and 1
                    joystickInput = data.vector.x;
                    
                    // Apply a small deadzone to prevent tiny movements
                    if (Math.abs(joystickInput) < 0.1) {
                        joystickInput = 0;
                    }
                    
                    // Clear keyboard inputs to avoid conflicts
                    keys['arrowleft'] = false;
                    keys['arrowright'] = false;
                });
                
                joystick.on('end', function() {
                    // Reset joystick input when released
                    joystickInput = 0;
                });
                
                // Set up touch event listeners for pedal controls
                const accelerateBtn = document.getElementById('accelerateBtn');
                const brakeBtn = document.getElementById('brakeBtn');
                const nitroBtn = document.getElementById('nitroBtn');
                
                // Acceleration button
                accelerateBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keys['arrowup'] = true;
                });
                accelerateBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keys['arrowup'] = false;
                });
                
                // Brake button
                brakeBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keys['arrowdown'] = true;
                });
                brakeBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keys['arrowdown'] = false;
                });
                
                // Nitro button
                nitroBtn.addEventListener('touchstart', function(e) {
                    e.preventDefault();
                    keys[' '] = true;
                });
                nitroBtn.addEventListener('touchend', function(e) {
                    e.preventDefault();
                    keys[' '] = false;
                });
                
                // Prevent default touch actions on the canvas to avoid scrolling
                renderer.domElement.addEventListener('touchmove', function(e) {
                    if (gameActive) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Prevent pinch zoom on mobile
                document.addEventListener('touchmove', function(e) {
                    if (e.touches.length > 1 && gameActive) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // Prevent double-tap zoom
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function(e) {
                    const now = Date.now();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, { passive: false });
            }
        }
    </script>
</body>
</html> 